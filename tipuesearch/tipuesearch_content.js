var tipuesearch = {"pages":[{"title":" ForBenchmark ","text":"ForBenchmark ForBenchmark : A Fortran library for benchmarking (with support for coarrays). Usage use forbenchmark type ( benchmark ) :: bench ! initialize the benchmark call bench % init () ! start benchmark call bench % start_benchmark ( method , argi ) ! loop over nloops do nl = 1 , bench % nloops ! call your function or subroutine or ... end do ! stop benchmark call bench % stop_benchmark () ! finalize the benchmark call bench % finalize () See example/demo.f90 for a complete example. fpm dependency To use ForBenchmark as a dependency in your fpm project, include the following line in your fpm.toml file: [dependencies] forbenchmark = { git = \"https://github.com/gha3mi/forbenchmark.git\" } How to Run the Demo Clone the repository: Clone the ForBenchmark repository from GitHub using: git clone https://github.com/gha3mi/forbenchmark.git cd forbenchmark Run the demo: For serial benchmarking: fpm run --example demo For coarray programs benchmarking using the Intel Fortran compiler: fpm run --example demo --compiler ifx --flag \"-coarray -coarray-num-images=4 -DUSE_COARRAY\" fpm run --example demo --compiler ifort --flag \"-coarray -coarray-num-images=4 -DUSE_COARRAY\" After execution, the results will be displayed in the terminal and stored in the results folder. TODO [ ] Write a Fortran/Python script to plot the benchmark results. [ ] Add CI_test.yml API documentation The most up-to-date API documentation for the main branch is available here .\nTo generate the API documentation for ForBenchmark using ford run the following\ncommand: ford ford.yml Contributing Contributions to ForBenchmark are welcome!\nIf you find any issues or would like to suggest improvements, please open an issue. Developer Info Seyed Ali Ghasemi","tags":"home","loc":"index.html"},{"title":"benchmark – ForBenchmark ","text":"type, public :: benchmark Inherits type~~benchmark~~InheritsGraph type~benchmark benchmark timer timer type~benchmark->timer time Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(timer), public :: time character(len=:), public, allocatable :: filename character(len=:), public, allocatable :: method character(len=:), public, allocatable :: description integer, public :: nloops integer, public, dimension(:), allocatable :: argi real(kind=rk), public, dimension(:), allocatable :: argr real(kind=rk), public :: gflops Type-Bound Procedures procedure, public :: init private impure elemental subroutine init (this, title, filename, nloops) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this character(len=*), intent(in), optional :: title character(len=*), intent(in), optional :: filename integer, intent(in), optional :: nloops procedure, public :: start_benchmark private impure subroutine start_benchmark (this, method, description, argi, argr) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this character(len=*), intent(in) :: method character(len=*), intent(in), optional :: description integer, intent(in), dimension(:) :: argi real(kind=rk), intent(in), optional, dimension(:) :: argr procedure, public :: stop_benchmark private impure subroutine stop_benchmark (this, flops) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this procedure(Fun), optional :: flops procedure, private :: write_benchmark private impure subroutine write_benchmark (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this procedure, public :: finalize private impure elemental subroutine finalize (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Source Code type :: benchmark type ( timer ) :: time character (:), allocatable :: filename character (:), allocatable :: method character (:), allocatable :: description integer :: nloops integer , dimension (:), allocatable :: argi real ( rk ), dimension (:), allocatable :: argr real ( rk ) :: gflops contains procedure :: init procedure :: start_benchmark procedure :: stop_benchmark procedure , private :: write_benchmark procedure :: finalize end type benchmark","tags":"","loc":"type/benchmark.html"},{"title":"benchmark – ForBenchmark ","text":"type, public :: benchmark Inherits type~~benchmark~2~~InheritsGraph type~benchmark~2 benchmark timer timer type~benchmark~2->timer time Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(timer), public, allocatable :: time [:] character(len=:), public, allocatable :: filename character(len=:), public, allocatable :: method character(len=:), public, allocatable :: description integer, public :: nloops integer, public, dimension(:), allocatable :: argi real(kind=rk), public, dimension(:), allocatable :: argr real(kind=rk), public, allocatable :: gflops [:] real(kind=rk), public :: elapsed_time_average real(kind=rk), public :: gflops_total Type-Bound Procedures procedure, public :: init private impure elemental subroutine init (this, title, filename, nloops) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this character(len=*), intent(in), optional :: title character(len=*), intent(in), optional :: filename integer, intent(in), optional :: nloops procedure, public :: start_benchmark private impure subroutine start_benchmark (this, method, description, argi, argr) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this character(len=*), intent(in) :: method character(len=*), intent(in), optional :: description integer, intent(in), dimension(:) :: argi real(kind=rk), intent(in), optional, dimension(:) :: argr procedure, public :: stop_benchmark private impure subroutine stop_benchmark (this, flops) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this procedure(Fun), optional :: flops procedure, private :: write_benchmark private impure subroutine write_benchmark (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this procedure, public :: finalize private impure elemental subroutine finalize (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Source Code type :: benchmark type ( timer ), allocatable :: time [:] character (:), allocatable :: filename character (:), allocatable :: method character (:), allocatable :: description integer :: nloops integer , dimension (:), allocatable :: argi real ( rk ), dimension (:), allocatable :: argr real ( rk ), allocatable :: gflops [:] real ( rk ) :: elapsed_time_average real ( rk ) :: gflops_total contains procedure :: init procedure :: start_benchmark procedure :: stop_benchmark procedure , private :: write_benchmark procedure :: finalize end type benchmark","tags":"","loc":"type/benchmark~2.html"},{"title":"current_date_and_time – ForBenchmark","text":"private impure function current_date_and_time() result(datetime) Arguments None Return Value character(len=21) Called by proc~~current_date_and_time~~CalledByGraph proc~current_date_and_time forbenchmark_default::current_date_and_time proc~init forbenchmark_default::benchmark%init proc~init->proc~current_date_and_time program~demo demo program~demo->proc~init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure function current_date_and_time () result ( datetime ) character ( 21 ) :: datetime character ( 10 ) :: date character ( 8 ) :: time integer :: values ( 8 ) character ( 4 ) :: year character ( 2 ) :: month , day , hour , minute , second call date_and_time ( values = values ) write ( year , '(i4)' ) values ( 1 ) write ( month , '(i2)' ) values ( 2 ) write ( day , '(i2)' ) values ( 3 ) write ( hour , '(i2)' ) values ( 5 ) write ( minute , '(i2)' ) values ( 6 ) write ( second , '(i2)' ) values ( 7 ) date = year // '.' // month // '.' // day time = hour // ':' // minute // ':' // second datetime = date // ' - ' // time end function current_date_and_time","tags":"","loc":"proc/current_date_and_time.html"},{"title":"init – ForBenchmark","text":"private impure elemental subroutine init(this, title, filename, nloops) Uses iso_fortran_env proc~~init~~UsesGraph proc~init forbenchmark_default::benchmark%init iso_fortran_env iso_fortran_env proc~init->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type Bound benchmark Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this character(len=*), intent(in), optional :: title character(len=*), intent(in), optional :: filename integer, intent(in), optional :: nloops Calls proc~~init~~CallsGraph proc~init forbenchmark_default::benchmark%init proc~current_date_and_time forbenchmark_default::current_date_and_time proc~init->proc~current_date_and_time Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~init~~CalledByGraph proc~init forbenchmark_default::benchmark%init program~demo demo program~demo->proc~init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental impure subroutine init ( this , title , filename , nloops ) use , intrinsic :: iso_fortran_env , only : compiler_version , compiler_options class ( benchmark ), intent ( inout ) :: this character ( * ), intent ( in ), optional :: title character ( * ), intent ( in ), optional :: filename integer , intent ( in ), optional :: nloops integer :: nunit logical :: exist integer :: iostat if ( present ( filename )) then this % filename = trim ( filename // '.data' ) else this % filename = 'benchmark.data' endif if ( present ( nloops )) then if ( nloops <= 0 ) error stop 'nloops must be greater than zero.' this % nloops = nloops else this % nloops = 10 end if inquire ( file = this % filename , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename ) write ( nunit , '(a)' ) '-----------------------------------------------------' write ( nunit , '(a)' ) 'ForBenchmark - https://github.com/gha3mi/forbenchmark' write ( nunit , '(a)' ) '-----------------------------------------------------' write ( nunit , '(a)' ) '' if ( present ( title )) then write ( nunit , '(a)' ) trim ( title ) else write ( nunit , '(a)' ) 'ForBenchmark' endif write ( nunit , '(a)' ) current_date_and_time () write ( nunit , '(a)' ) '' write ( nunit , '(a,a)' ) 'compiler_version: ' , compiler_version () write ( nunit , '(a,a)' ) 'compiler_options: ' , compiler_options () write ( nunit , '(a)' ) '' write ( nunit , '(a)' ) & & '       METHOD        |& &         TIME         |& &        GFLOPS        |& &  NLOOPS  |& &   ARGS  ' close ( nunit ) end subroutine init","tags":"","loc":"proc/init.html"},{"title":"start_benchmark – ForBenchmark","text":"private impure subroutine start_benchmark(this, method, description, argi, argr) Uses face proc~~start_benchmark~~UsesGraph proc~start_benchmark forbenchmark_default::benchmark%start_benchmark face face proc~start_benchmark->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type Bound benchmark Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this character(len=*), intent(in) :: method character(len=*), intent(in), optional :: description integer, intent(in), dimension(:) :: argi real(kind=rk), intent(in), optional, dimension(:) :: argr Calls proc~~start_benchmark~~CallsGraph proc~start_benchmark forbenchmark_default::benchmark%start_benchmark colorize colorize proc~start_benchmark->colorize timer_start timer_start proc~start_benchmark->timer_start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~start_benchmark~~CalledByGraph proc~start_benchmark forbenchmark_default::benchmark%start_benchmark program~demo demo program~demo->proc~start_benchmark Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine start_benchmark ( this , method , description , argi , argr ) use face class ( benchmark ), intent ( inout ) :: this character ( * ), intent ( in ) :: method integer , dimension (:), intent ( in ) :: argi real ( rk ), dimension (:), intent ( in ), optional :: argr character ( * ), intent ( in ), optional :: description this % description = description this % method = method this % argi = argi if ( present ( argr )) then this % argr = argr else if (. not . allocated ( this % argr )) allocate ( this % argr ( 0 )) endif if ( present ( description )) then print '(a,a,\" \",a,*(g0,1x))' ,& colorize ( 'Meth.: ' // this % method , color_fg = 'green' , style = 'bold_on' ),& colorize ( '; Des.: ' // this % description , color_fg = 'green_intense' ),& '; Args.:' ,& this % argi else print '(a,\" \",*(g0,1x))' ,& colorize ( 'Meth.: ' // this % method , color_fg = 'green' , style = 'bold_on' ), this % argi end if call this % time % timer_start () end subroutine start_benchmark","tags":"","loc":"proc/start_benchmark.html"},{"title":"stop_benchmark – ForBenchmark","text":"private impure subroutine stop_benchmark(this, flops) Type Bound benchmark Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this procedure(Fun), optional :: flops Calls proc~~stop_benchmark~~CallsGraph proc~stop_benchmark forbenchmark_default::benchmark%stop_benchmark proc~write_benchmark forbenchmark_default::benchmark%write_benchmark proc~stop_benchmark->proc~write_benchmark timer_stop timer_stop proc~stop_benchmark->timer_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~stop_benchmark~~CalledByGraph proc~stop_benchmark forbenchmark_default::benchmark%stop_benchmark program~demo demo program~demo->proc~stop_benchmark Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine stop_benchmark ( this , flops ) interface impure function Fun ( argi , argr ) import rk integer , dimension (:), intent ( in ) :: argi real ( rk ), dimension (:), intent ( in ), optional :: argr real ( rk ) :: Fun end function Fun end interface procedure ( Fun ), optional :: flops class ( benchmark ), intent ( inout ) :: this call this % time % timer_stop ( message = ' Elapsed time :' , nloops = this % nloops ) if ( present ( flops )) then this % gflops = flops ( this % argi , this % argr ) / this % time % elapsed_time print '(a,f6.2,a)' , ' Performance  : ' , this % gflops , ' [GFLOPS]' else this % gflops = 0.0_rk endif print '(a)' , '' call this % write_benchmark () end subroutine stop_benchmark","tags":"","loc":"proc/stop_benchmark.html"},{"title":"write_benchmark – ForBenchmark","text":"private impure subroutine write_benchmark(this) Type Bound benchmark Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Called by proc~~write_benchmark~~CalledByGraph proc~write_benchmark forbenchmark_default::benchmark%write_benchmark proc~stop_benchmark forbenchmark_default::benchmark%stop_benchmark proc~stop_benchmark->proc~write_benchmark program~demo demo program~demo->proc~stop_benchmark Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine write_benchmark ( this ) class ( benchmark ), intent ( inout ) :: this integer :: nunit character ( len = 55 ) :: fmt integer :: lm logical :: exist integer :: iostat lm = 20 - len_trim ( this % method ) write ( fmt , '(a,g0,a)' ) '(a,' , lm , 'x,3x,E20.14,3x,E20.14,3x,g8.0,3x,*(g8.0,3x))' inquire ( file = this % filename , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename , access = 'append' ) write ( nunit , fmt ) & this % method , this % time % elapsed_time , this % gflops , this % nloops , this % argi close ( nunit ) end subroutine write_benchmark","tags":"","loc":"proc/write_benchmark.html"},{"title":"finalize – ForBenchmark","text":"private impure elemental subroutine finalize(this) Type Bound benchmark Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Called by proc~~finalize~~CalledByGraph proc~finalize forbenchmark_default::benchmark%finalize program~demo demo program~demo->proc~finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental impure subroutine finalize ( this ) class ( benchmark ), intent ( inout ) :: this integer :: nunit logical :: exist integer :: iostat inquire ( file = this % filename , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename , access = 'append' ) write ( nunit , '(a)' ) 'end of benchmark' close ( nunit ) if ( allocated ( this % filename )) deallocate ( this % filename ) if ( allocated ( this % method )) deallocate ( this % method ) if ( allocated ( this % description )) deallocate ( this % description ) if ( allocated ( this % argi )) deallocate ( this % argi ) if ( allocated ( this % argr )) deallocate ( this % argr ) print '(a)' , 'end of benchmark' end subroutine finalize","tags":"","loc":"proc/finalize.html"},{"title":"unit_test_r0 – ForBenchmark","text":"private  subroutine unit_test_r0(res, expected, tol, message) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: res real(kind=rk), intent(in) :: expected real(kind=rk), intent(in) :: tol character(len=*), intent(in) :: message Calls proc~~unit_test_r0~~CallsGraph proc~unit_test_r0 forunittest::unit_test_r0 proc~print_message forunittest::print_message proc~unit_test_r0->proc~print_message colorize colorize proc~print_message->colorize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~unit_test_r0~~CalledByGraph proc~unit_test_r0 forunittest::unit_test_r0 interface~unit_test forunittest::unit_test interface~unit_test->proc~unit_test_r0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine unit_test_r0 ( res , expected , tol , message ) real ( rk ), intent ( in ) :: res , expected real ( rk ), intent ( in ) :: tol character ( * ), intent ( in ) :: message logical :: condition integer :: lm character ( len = 20 ) :: fmt real ( rk ) :: rel_err lm = 46 - len_trim ( message ) write ( fmt , '(a,g0,a)' ) '(a,a' , lm , ',a)' if ( abs ( expected ) < tiny ( 0.0_rk )) then rel_err = abs ( res - expected ) else rel_err = abs ( res - expected ) / abs ( expected ) end if condition = rel_err < tol call print_message ( condition , message ) end subroutine unit_test_r0","tags":"","loc":"proc/unit_test_r0.html"},{"title":"unit_test_r1 – ForBenchmark","text":"private  subroutine unit_test_r1(res, expected, tol, message) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: res real(kind=rk), intent(in), dimension(:) :: expected real(kind=rk), intent(in) :: tol character(len=*), intent(in) :: message Calls proc~~unit_test_r1~~CallsGraph proc~unit_test_r1 forunittest::unit_test_r1 proc~print_message forunittest::print_message proc~unit_test_r1->proc~print_message colorize colorize proc~print_message->colorize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~unit_test_r1~~CalledByGraph proc~unit_test_r1 forunittest::unit_test_r1 interface~unit_test forunittest::unit_test interface~unit_test->proc~unit_test_r1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine unit_test_r1 ( res , expected , tol , message ) real ( rk ), intent ( in ), dimension (:) :: res , expected real ( rk ), intent ( in ) :: tol character ( * ), intent ( in ) :: message logical :: condition integer :: lm character ( len = 20 ) :: fmt real ( rk ) :: rel_err lm = 46 - len_trim ( message ) write ( fmt , '(a,g0,a)' ) '(a,a' , lm , ',a)' if ( norm2 ( expected ) < tiny ( 0.0_rk )) then rel_err = norm2 ( res - expected ) else rel_err = norm2 ( res - expected ) / norm2 ( expected ) end if condition = rel_err < tol call print_message ( condition , message ) end subroutine unit_test_r1","tags":"","loc":"proc/unit_test_r1.html"},{"title":"unit_test_r2 – ForBenchmark","text":"private  subroutine unit_test_r2(res, expected, tol, message) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: res real(kind=rk), intent(in), dimension(:,:) :: expected real(kind=rk), intent(in) :: tol character(len=*), intent(in) :: message Calls proc~~unit_test_r2~~CallsGraph proc~unit_test_r2 forunittest::unit_test_r2 proc~print_message forunittest::print_message proc~unit_test_r2->proc~print_message colorize colorize proc~print_message->colorize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~unit_test_r2~~CalledByGraph proc~unit_test_r2 forunittest::unit_test_r2 interface~unit_test forunittest::unit_test interface~unit_test->proc~unit_test_r2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine unit_test_r2 ( res , expected , tol , message ) real ( rk ), intent ( in ), dimension (:,:) :: res , expected real ( rk ), intent ( in ) :: tol character ( * ), intent ( in ) :: message logical :: condition integer :: lm character ( len = 20 ) :: fmt real ( rk ) :: rel_err lm = 46 - len_trim ( message ) write ( fmt , '(a,g0,a)' ) '(a,a' , lm , ',a)' if ( norm2 ( expected ) < tiny ( 0.0_rk )) then rel_err = norm2 ( res - expected ) else rel_err = norm2 ( res - expected ) / norm2 ( expected ) end if condition = rel_err < tol call print_message ( condition , message ) end subroutine unit_test_r2","tags":"","loc":"proc/unit_test_r2.html"},{"title":"unit_test_compare_r1 – ForBenchmark","text":"private  subroutine unit_test_compare_r1(u, v, message) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: u real(kind=rk), intent(in), dimension(:) :: v character(len=*), intent(in) :: message Calls proc~~unit_test_compare_r1~~CallsGraph proc~unit_test_compare_r1 forunittest::unit_test_compare_r1 proc~print_message forunittest::print_message proc~unit_test_compare_r1->proc~print_message colorize colorize proc~print_message->colorize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~unit_test_compare_r1~~CalledByGraph proc~unit_test_compare_r1 forunittest::unit_test_compare_r1 interface~unit_test forunittest::unit_test interface~unit_test->proc~unit_test_compare_r1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine unit_test_compare_r1 ( u , v , message ) real ( rk ), intent ( in ), dimension (:) :: u , v character ( * ), intent ( in ) :: message logical :: condition integer :: lm character ( len = 20 ) :: fmt real ( rk ) :: rel_err lm = 46 - len_trim ( message ) write ( fmt , '(a,g0,a)' ) '(a,a' , lm , ',a)' condition = any ( u == v ) call print_message ( condition , message ) end subroutine unit_test_compare_r1","tags":"","loc":"proc/unit_test_compare_r1.html"},{"title":"unit_test_compare_i1 – ForBenchmark","text":"private  subroutine unit_test_compare_i1(u, v, message) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: u integer, intent(in), dimension(:) :: v character(len=*), intent(in) :: message Calls proc~~unit_test_compare_i1~~CallsGraph proc~unit_test_compare_i1 forunittest::unit_test_compare_i1 proc~print_message forunittest::print_message proc~unit_test_compare_i1->proc~print_message colorize colorize proc~print_message->colorize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~unit_test_compare_i1~~CalledByGraph proc~unit_test_compare_i1 forunittest::unit_test_compare_i1 interface~unit_test forunittest::unit_test interface~unit_test->proc~unit_test_compare_i1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine unit_test_compare_i1 ( u , v , message ) integer , intent ( in ), dimension (:) :: u , v character ( * ), intent ( in ) :: message logical :: condition integer :: lm character ( len = 20 ) :: fmt real ( rk ) :: rel_err lm = 46 - len_trim ( message ) write ( fmt , '(a,g0,a)' ) '(a,a' , lm , ',a)' condition = any ( u == v ) call print_message ( condition , message ) end subroutine unit_test_compare_i1","tags":"","loc":"proc/unit_test_compare_i1.html"},{"title":"print_message – ForBenchmark","text":"private  subroutine print_message(condition, message) Uses face proc~~print_message~~UsesGraph proc~print_message forunittest::print_message face face proc~print_message->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition character(len=*), intent(in) :: message Calls proc~~print_message~~CallsGraph proc~print_message forunittest::print_message colorize colorize proc~print_message->colorize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_message~~CalledByGraph proc~print_message forunittest::print_message proc~unit_test_compare_i1 forunittest::unit_test_compare_i1 proc~unit_test_compare_i1->proc~print_message proc~unit_test_compare_r1 forunittest::unit_test_compare_r1 proc~unit_test_compare_r1->proc~print_message proc~unit_test_r0 forunittest::unit_test_r0 proc~unit_test_r0->proc~print_message proc~unit_test_r1 forunittest::unit_test_r1 proc~unit_test_r1->proc~print_message proc~unit_test_r2 forunittest::unit_test_r2 proc~unit_test_r2->proc~print_message interface~unit_test forunittest::unit_test interface~unit_test->proc~unit_test_compare_i1 interface~unit_test->proc~unit_test_compare_r1 interface~unit_test->proc~unit_test_r0 interface~unit_test->proc~unit_test_r1 interface~unit_test->proc~unit_test_r2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine print_message ( condition , message ) use face logical , intent ( in ) :: condition character ( * ), intent ( in ) :: message integer :: lm character ( len = 20 ) :: fmt lm = 55 - len_trim ( message ) write ( fmt , '(a,g0,a)' ) '(a,a' , lm , ',a)' if ( condition ) then print ( fmt ), message , colorize ( 'passed.' , color_fg = 'green' ) else print ( fmt ), message , colorize ( 'failed.' , color_fg = 'red' ) end if end subroutine print_message","tags":"","loc":"proc/print_message.html"},{"title":"unit_test – ForBenchmark","text":"public interface unit_test Calls interface~~unit_test~~CallsGraph interface~unit_test forunittest::unit_test proc~unit_test_compare_i1 forunittest::unit_test_compare_i1 interface~unit_test->proc~unit_test_compare_i1 proc~unit_test_compare_r1 forunittest::unit_test_compare_r1 interface~unit_test->proc~unit_test_compare_r1 proc~unit_test_r0 forunittest::unit_test_r0 interface~unit_test->proc~unit_test_r0 proc~unit_test_r1 forunittest::unit_test_r1 interface~unit_test->proc~unit_test_r1 proc~unit_test_r2 forunittest::unit_test_r2 interface~unit_test->proc~unit_test_r2 proc~print_message forunittest::print_message proc~unit_test_compare_i1->proc~print_message proc~unit_test_compare_r1->proc~print_message proc~unit_test_r0->proc~print_message proc~unit_test_r1->proc~print_message proc~unit_test_r2->proc~print_message colorize colorize proc~print_message->colorize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  subroutine unit_test_r0 (res, expected, tol, message) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: res real(kind=rk), intent(in) :: expected real(kind=rk), intent(in) :: tol character(len=*), intent(in) :: message private  subroutine unit_test_r1 (res, expected, tol, message) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: res real(kind=rk), intent(in), dimension(:) :: expected real(kind=rk), intent(in) :: tol character(len=*), intent(in) :: message private  subroutine unit_test_r2 (res, expected, tol, message) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: res real(kind=rk), intent(in), dimension(:,:) :: expected real(kind=rk), intent(in) :: tol character(len=*), intent(in) :: message private  subroutine unit_test_compare_r1 (u, v, message) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: u real(kind=rk), intent(in), dimension(:) :: v character(len=*), intent(in) :: message private  subroutine unit_test_compare_i1 (u, v, message) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: u integer, intent(in), dimension(:) :: v character(len=*), intent(in) :: message","tags":"","loc":"interface/unit_test.html"},{"title":"current_date_and_time – ForBenchmark","text":"private impure function current_date_and_time() result(datetime) Arguments None Return Value character(len=21) Called by proc~~current_date_and_time~2~~CalledByGraph proc~current_date_and_time~2 forbenchmark_coarray::current_date_and_time proc~init~2 forbenchmark_coarray::benchmark%init proc~init~2->proc~current_date_and_time~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure function current_date_and_time () result ( datetime ) character ( 21 ) :: datetime character ( 10 ) :: date character ( 8 ) :: time integer :: values ( 8 ) character ( 4 ) :: year character ( 2 ) :: month , day , hour , minute , second call date_and_time ( values = values ) write ( year , '(i4)' ) values ( 1 ) write ( month , '(i2)' ) values ( 2 ) write ( day , '(i2)' ) values ( 3 ) write ( hour , '(i2)' ) values ( 5 ) write ( minute , '(i2)' ) values ( 6 ) write ( second , '(i2)' ) values ( 7 ) date = year // '.' // month // '.' // day time = hour // ':' // minute // ':' // second datetime = date // ' - ' // time end function current_date_and_time","tags":"","loc":"proc/current_date_and_time~2.html"},{"title":"init – ForBenchmark","text":"private impure elemental subroutine init(this, title, filename, nloops) Uses iso_fortran_env proc~~init~2~~UsesGraph proc~init~2 forbenchmark_coarray::benchmark%init iso_fortran_env iso_fortran_env proc~init~2->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type Bound benchmark Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this character(len=*), intent(in), optional :: title character(len=*), intent(in), optional :: filename integer, intent(in), optional :: nloops Calls proc~~init~2~~CallsGraph proc~init~2 forbenchmark_coarray::benchmark%init proc~current_date_and_time~2 forbenchmark_coarray::current_date_and_time proc~init~2->proc~current_date_and_time~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental impure subroutine init ( this , title , filename , nloops ) use , intrinsic :: iso_fortran_env , only : compiler_version , compiler_options class ( benchmark ), intent ( inout ) :: this character ( * ), intent ( in ), optional :: title character ( * ), intent ( in ), optional :: filename integer , intent ( in ), optional :: nloops integer :: nunit logical :: exist integer :: iostat character ( 10 ) :: im_chr write ( im_chr , '(i0)' ) this_image () if ( present ( filename )) then this % filename = trim ( filename // '_im' // trim ( im_chr ) // '.data' ) else this % filename = trim ( 'benchmark' // '_im' // trim ( im_chr ) // '.data' ) end if if ( present ( nloops )) then if ( nloops <= 0 ) error stop 'nloops must be greater than zero.' this % nloops = nloops else this % nloops = 10 end if allocate ( this % time [ * ]) allocate ( this % gflops [ * ]) inquire ( file = this % filename , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename ) write ( nunit , '(a)' ) '-----------------------------------------------------' write ( nunit , '(a)' ) 'ForBenchmark - https://github.com/gha3mi/forbenchmark' write ( nunit , '(a)' ) '-----------------------------------------------------' write ( nunit , '(a)' ) '' if ( present ( title )) then write ( nunit , '(a)' ) trim ( title ) else write ( nunit , '(a)' ) 'ForBenchmark' end if write ( nunit , '(a)' ) current_date_and_time () write ( nunit , '(a)' ) '' write ( nunit , '(a,a)' ) 'compiler_version: ' , compiler_version () write ( nunit , '(a,a)' ) 'compiler_options: ' , compiler_options () write ( nunit , '(a)' ) '' write ( nunit , '(a)' ) & & '       METHOD        |& &      TIME(avg)       |& &     GFLOPS(tot)      |& &     TIME(image)      |& &    GFLOPS(image)     |& &  NLOOPS  |& &   ARGS  ' close ( nunit ) end subroutine init","tags":"","loc":"proc/init~2.html"},{"title":"start_benchmark – ForBenchmark","text":"private impure subroutine start_benchmark(this, method, description, argi, argr) Uses face proc~~start_benchmark~2~~UsesGraph proc~start_benchmark~2 forbenchmark_coarray::benchmark%start_benchmark face face proc~start_benchmark~2->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type Bound benchmark Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this character(len=*), intent(in) :: method character(len=*), intent(in), optional :: description integer, intent(in), dimension(:) :: argi real(kind=rk), intent(in), optional, dimension(:) :: argr Calls proc~~start_benchmark~2~~CallsGraph proc~start_benchmark~2 forbenchmark_coarray::benchmark%start_benchmark colorize colorize proc~start_benchmark~2->colorize timer_start timer_start proc~start_benchmark~2->timer_start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine start_benchmark ( this , method , description , argi , argr ) use face class ( benchmark ), intent ( inout ) :: this character ( * ), intent ( in ) :: method integer , dimension (:), intent ( in ) :: argi real ( rk ), dimension (:), intent ( in ), optional :: argr character ( * ), intent ( in ), optional :: description this % description = description this % method = method this % argi = argi if ( present ( argr )) then this % argr = argr else if (. not . allocated ( this % argr )) allocate ( this % argr ( 0 )) endif sync all if ( present ( description ) . and . this_image () == 1 ) then print '(a,a,\" \",a,*(g0,1x))' ,& colorize ( 'Meth.: ' // this % method , color_fg = 'green' , style = 'bold_on' ),& colorize ( '; Des.: ' // this % description , color_fg = 'green_intense' ),& '; Args.:' ,& this % argi elseif (. not . present ( description ) . and . this_image () == 1 ) then print '(a,\" \",*(g0,1x))' ,& colorize ( 'Meth.: ' // this % method , color_fg = 'green' , style = 'bold_on' ), this % argi end if call this % time [ this_image ()]% timer_start () end subroutine start_benchmark","tags":"","loc":"proc/start_benchmark~2.html"},{"title":"stop_benchmark – ForBenchmark","text":"private impure subroutine stop_benchmark(this, flops) Uses face proc~~stop_benchmark~2~~UsesGraph proc~stop_benchmark~2 forbenchmark_coarray::benchmark%stop_benchmark face face proc~stop_benchmark~2->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type Bound benchmark Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this procedure(Fun), optional :: flops Calls proc~~stop_benchmark~2~~CallsGraph proc~stop_benchmark~2 forbenchmark_coarray::benchmark%stop_benchmark colorize colorize proc~stop_benchmark~2->colorize proc~write_benchmark~2 forbenchmark_coarray::benchmark%write_benchmark proc~stop_benchmark~2->proc~write_benchmark~2 timer_stop timer_stop proc~stop_benchmark~2->timer_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine stop_benchmark ( this , flops ) use face interface impure function Fun ( argi , argr ) import rk integer , dimension (:), intent ( in ) :: argi real ( rk ), dimension (:), intent ( in ), optional :: argr real ( rk ) :: Fun end function Fun end interface procedure ( Fun ), optional :: flops class ( benchmark ), intent ( inout ) :: this real ( rk ) :: elapsed_time_average real ( rk ) :: gflops_total integer :: i call this % time [ this_image ()]% timer_stop ( message = ' Elapsed time :' , nloops = this % nloops ) if ( present ( flops )) then this % gflops [ this_image ()] = flops ( this % argi , this % argr ) / this % time [ this_image ()]% elapsed_time print '(a,f6.2,a)' , ' Performance  : ' , this % gflops [ this_image ()], ' [GFLOPS/image]' else this % gflops [ this_image ()] = 0.0_rk end if sync all if ( this_image () == 1 ) then elapsed_time_average = 0.0_rk if ( present ( flops )) gflops_total = 0.0_rk do i = 1 , num_images () elapsed_time_average = elapsed_time_average + this % time [ i ]% elapsed_time if ( present ( flops )) gflops_total = gflops_total + this % gflops [ i ] end do elapsed_time_average = elapsed_time_average / num_images () print '(a,f7.3,a)' , colorize ( ' Elapsed time (average) :' , color_fg = 'blue' ),& elapsed_time_average , ' [s]' if ( present ( flops )) print '(a,f6.2,a)' , colorize ( ' Performance  (total)   : ' , color_fg = 'cyan' ),& gflops_total , ' [GFLOPS]' print '(a)' , '' end if call co_broadcast ( elapsed_time_average , 1 ) if ( present ( flops )) call co_broadcast ( gflops_total , 1 ) this % elapsed_time_average = elapsed_time_average if ( present ( flops )) then this % gflops_total = gflops_total else this % gflops_total = 0.0_rk end if call this % write_benchmark () end subroutine stop_benchmark","tags":"","loc":"proc/stop_benchmark~2.html"},{"title":"write_benchmark – ForBenchmark","text":"private impure subroutine write_benchmark(this) Type Bound benchmark Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Called by proc~~write_benchmark~2~~CalledByGraph proc~write_benchmark~2 forbenchmark_coarray::benchmark%write_benchmark proc~stop_benchmark~2 forbenchmark_coarray::benchmark%stop_benchmark proc~stop_benchmark~2->proc~write_benchmark~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine write_benchmark ( this ) class ( benchmark ), intent ( inout ) :: this integer :: nunit character ( len = 75 ) :: fmt integer :: lm logical :: exist integer :: iostat lm = 20 - len_trim ( this % method ) write ( fmt , '(a,g0,a)' ) '(a,' , lm , 'x,3x,E20.14,3x,E20.14,3x,E20.14,3x,E20.14,3x,g8.0,3x,*(g8.0,3x))' inquire ( file = this % filename , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename , access = 'append' ) write ( nunit , fmt ) & this % method ,& this % elapsed_time_average ,& this % gflops_total ,& this % time [ this_image ()]% elapsed_time ,& this % gflops [ this_image ()],& this % nloops ,& this % argi close ( nunit ) end subroutine write_benchmark","tags":"","loc":"proc/write_benchmark~2.html"},{"title":"finalize – ForBenchmark","text":"private impure elemental subroutine finalize(this) Type Bound benchmark Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Source Code elemental impure subroutine finalize ( this ) class ( benchmark ), intent ( inout ) :: this integer :: nunit logical :: exist integer :: iostat inquire ( file = this % filename , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename , access = 'append' ) write ( nunit , '(a)' ) 'end of benchmark' close ( nunit ) if ( allocated ( this % filename )) deallocate ( this % filename ) if ( allocated ( this % method )) deallocate ( this % method ) if ( allocated ( this % description )) deallocate ( this % description ) if ( allocated ( this % argi )) deallocate ( this % argi ) if ( allocated ( this % argr )) deallocate ( this % argr ) if ( allocated ( this % time )) deallocate ( this % time ) if ( allocated ( this % gflops )) deallocate ( this % gflops ) if ( this_image () == 1 ) print '(a)' , 'end of benchmark' end subroutine finalize","tags":"","loc":"proc/finalize~2.html"},{"title":"cmp_gflops – ForBenchmark","text":"function cmp_gflops(argi, argr) result(gflops) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: argi real(kind=rk), intent(in), optional, dimension(:) :: argr Return Value real(kind=rk) Source Code function cmp_gflops ( argi , argr ) result ( gflops ) integer , dimension (:), intent ( in ) :: argi real ( rk ), dimension (:), intent ( in ), optional :: argr real ( rk ) :: gflops gflops = real ( argi ( 1 ), rk ) * real ( argi ( 2 ), rk ) * real ( argi ( 3 ), rk ) * 1.0e-9_rk end function cmp_gflops","tags":"","loc":"proc/cmp_gflops.html"},{"title":"forbenchmark_default – ForBenchmark","text":"Uses kinds fortime module~~forbenchmark_default~~UsesGraph module~forbenchmark_default forbenchmark_default fortime fortime module~forbenchmark_default->fortime kinds kinds module~forbenchmark_default->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forbenchmark_default~~UsedByGraph module~forbenchmark_default forbenchmark_default module~forbenchmark forbenchmark module~forbenchmark->module~forbenchmark_default program~demo demo program~demo->module~forbenchmark Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: benchmark Components Type Visibility Attributes Name Initial type(timer), public :: time character(len=:), public, allocatable :: filename character(len=:), public, allocatable :: method character(len=:), public, allocatable :: description integer, public :: nloops integer, public, dimension(:), allocatable :: argi real(kind=rk), public, dimension(:), allocatable :: argr real(kind=rk), public :: gflops Type-Bound Procedures procedure, public :: init procedure, public :: start_benchmark procedure, public :: stop_benchmark procedure, private :: write_benchmark procedure, public :: finalize Functions private impure function current_date_and_time () result(datetime) Author Seyed Ali Ghasemi Arguments None Return Value character(len=21) Subroutines private impure elemental subroutine init (this, title, filename, nloops) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this character(len=*), intent(in), optional :: title character(len=*), intent(in), optional :: filename integer, intent(in), optional :: nloops private impure subroutine start_benchmark (this, method, description, argi, argr) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this character(len=*), intent(in) :: method character(len=*), intent(in), optional :: description integer, intent(in), dimension(:) :: argi real(kind=rk), intent(in), optional, dimension(:) :: argr private impure subroutine stop_benchmark (this, flops) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this procedure(Fun), optional :: flops private impure subroutine write_benchmark (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this private impure elemental subroutine finalize (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this","tags":"","loc":"module/forbenchmark_default.html"},{"title":"forunittest – ForBenchmark","text":"Uses kinds module~~forunittest~~UsesGraph module~forunittest forunittest kinds kinds module~forunittest->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface unit_test private  subroutine unit_test_r0 (res, expected, tol, message) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: res real(kind=rk), intent(in) :: expected real(kind=rk), intent(in) :: tol character(len=*), intent(in) :: message private  subroutine unit_test_r1 (res, expected, tol, message) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: res real(kind=rk), intent(in), dimension(:) :: expected real(kind=rk), intent(in) :: tol character(len=*), intent(in) :: message private  subroutine unit_test_r2 (res, expected, tol, message) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: res real(kind=rk), intent(in), dimension(:,:) :: expected real(kind=rk), intent(in) :: tol character(len=*), intent(in) :: message private  subroutine unit_test_compare_r1 (u, v, message) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: u real(kind=rk), intent(in), dimension(:) :: v character(len=*), intent(in) :: message private  subroutine unit_test_compare_i1 (u, v, message) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: u integer, intent(in), dimension(:) :: v character(len=*), intent(in) :: message Subroutines private  subroutine unit_test_r0 (res, expected, tol, message) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: res real(kind=rk), intent(in) :: expected real(kind=rk), intent(in) :: tol character(len=*), intent(in) :: message private  subroutine unit_test_r1 (res, expected, tol, message) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: res real(kind=rk), intent(in), dimension(:) :: expected real(kind=rk), intent(in) :: tol character(len=*), intent(in) :: message private  subroutine unit_test_r2 (res, expected, tol, message) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: res real(kind=rk), intent(in), dimension(:,:) :: expected real(kind=rk), intent(in) :: tol character(len=*), intent(in) :: message private  subroutine unit_test_compare_r1 (u, v, message) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: u real(kind=rk), intent(in), dimension(:) :: v character(len=*), intent(in) :: message private  subroutine unit_test_compare_i1 (u, v, message) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: u integer, intent(in), dimension(:) :: v character(len=*), intent(in) :: message private  subroutine print_message (condition, message) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition character(len=*), intent(in) :: message","tags":"","loc":"module/forunittest.html"},{"title":"forbenchmark_coarray – ForBenchmark","text":"Uses kinds fortime module~~forbenchmark_coarray~~UsesGraph module~forbenchmark_coarray forbenchmark_coarray fortime fortime module~forbenchmark_coarray->fortime kinds kinds module~forbenchmark_coarray->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forbenchmark_coarray~~UsedByGraph module~forbenchmark_coarray forbenchmark_coarray module~forbenchmark forbenchmark module~forbenchmark->module~forbenchmark_coarray program~demo demo program~demo->module~forbenchmark Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: benchmark Components Type Visibility Attributes Name Initial type(timer), public, allocatable :: time [:] character(len=:), public, allocatable :: filename character(len=:), public, allocatable :: method character(len=:), public, allocatable :: description integer, public :: nloops integer, public, dimension(:), allocatable :: argi real(kind=rk), public, dimension(:), allocatable :: argr real(kind=rk), public, allocatable :: gflops [:] real(kind=rk), public :: elapsed_time_average real(kind=rk), public :: gflops_total Type-Bound Procedures procedure, public :: init procedure, public :: start_benchmark procedure, public :: stop_benchmark procedure, private :: write_benchmark procedure, public :: finalize Functions private impure function current_date_and_time () result(datetime) Author Seyed Ali Ghasemi Arguments None Return Value character(len=21) Subroutines private impure elemental subroutine init (this, title, filename, nloops) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this character(len=*), intent(in), optional :: title character(len=*), intent(in), optional :: filename integer, intent(in), optional :: nloops private impure subroutine start_benchmark (this, method, description, argi, argr) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this character(len=*), intent(in) :: method character(len=*), intent(in), optional :: description integer, intent(in), dimension(:) :: argi real(kind=rk), intent(in), optional, dimension(:) :: argr private impure subroutine stop_benchmark (this, flops) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this procedure(Fun), optional :: flops private impure subroutine write_benchmark (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this private impure elemental subroutine finalize (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this","tags":"","loc":"module/forbenchmark_coarray.html"},{"title":"forbenchmark – ForBenchmark","text":"Uses forbenchmark_coarray forbenchmark_default module~~forbenchmark~~UsesGraph module~forbenchmark forbenchmark module~forbenchmark_coarray forbenchmark_coarray module~forbenchmark->module~forbenchmark_coarray module~forbenchmark_default forbenchmark_default module~forbenchmark->module~forbenchmark_default fortime fortime module~forbenchmark_coarray->fortime kinds kinds module~forbenchmark_coarray->kinds module~forbenchmark_default->fortime module~forbenchmark_default->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forbenchmark~~UsedByGraph module~forbenchmark forbenchmark program~demo demo program~demo->module~forbenchmark Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"module/forbenchmark.html"},{"title":"demo – ForBenchmark","text":"Uses kinds forbenchmark program~~demo~~UsesGraph program~demo demo kinds kinds program~demo->kinds module~forbenchmark forbenchmark program~demo->module~forbenchmark module~forbenchmark_coarray forbenchmark_coarray module~forbenchmark->module~forbenchmark_coarray module~forbenchmark_default forbenchmark_default module~forbenchmark->module~forbenchmark_default module~forbenchmark_coarray->kinds fortime fortime module~forbenchmark_coarray->fortime module~forbenchmark_default->kinds module~forbenchmark_default->fortime Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~demo~~CallsGraph program~demo demo proc~finalize forbenchmark_default::benchmark%finalize program~demo->proc~finalize proc~init forbenchmark_default::benchmark%init program~demo->proc~init proc~start_benchmark forbenchmark_default::benchmark%start_benchmark program~demo->proc~start_benchmark proc~stop_benchmark forbenchmark_default::benchmark%stop_benchmark program~demo->proc~stop_benchmark proc~current_date_and_time forbenchmark_default::current_date_and_time proc~init->proc~current_date_and_time colorize colorize proc~start_benchmark->colorize timer_start timer_start proc~start_benchmark->timer_start proc~write_benchmark forbenchmark_default::benchmark%write_benchmark proc~stop_benchmark->proc~write_benchmark timer_stop timer_stop proc~stop_benchmark->timer_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( benchmark ) :: bench real(kind=rk), dimension(:,:), allocatable :: A real(kind=rk), dimension(:,:), allocatable :: B real(kind=rk), dimension(:,:), allocatable :: C integer :: nl integer :: p integer :: i integer :: j integer :: k Functions function cmp_gflops (argi, argr) result(gflops) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: argi real(kind=rk), intent(in), optional, dimension(:) :: argr Return Value real(kind=rk) Source Code program demo use kinds , only : rk ! use -DREAL32 or -DREAL64 to switch between real32 and real64, default is real64 use forbenchmark , only : benchmark ! forbenchmark module implicit none ! benchmark object type ( benchmark ) :: bench ! define your variables here real ( rk ), dimension (:,:), allocatable :: A , B , C integer :: nl , p , i , j , k ! initialize the benchmark ! title: optional ! filename: optional. make sure directory exists ! nloops: optional. number of loops for each benchmark. default is 10. call bench % init ( title = 'MatMul Benchmark' , filename = 'results/demo_matmul' , nloops = 10 ) ! start the benchmark do p = 100 , 400 , 100 ! loop over problem size !=============================================================================== ! allocate and initialize your variables here if ( allocated ( A )) deallocate ( A ) if ( allocated ( B )) deallocate ( B ) if ( allocated ( C )) deallocate ( C ) allocate ( A ( p , p )) allocate ( B ( p , p )) allocate ( C ( p , p ), source = 0.0_rk ) call random_number ( A ) call random_number ( B ) !=============================================================================== !=============================================================================== ! start benchmark for method 1 ! method is a string to identify the method ! description is optional ! argi is an integer array of arguments, to write in the output file ! argr is a real array of arguments, optional call bench % start_benchmark ( method = 'matmul_m1' , description = 'intrinsic, C = matmul(A,B)' , argi = [ p , p , p ]) ! loop over nloops do nl = 1 , bench % nloops ! call your function or subroutine or ... ! here is used intrinsic matmul C = matmul ( A , B ) end do ! stop benchmark for method 1 ! cmp_gflops is an optional function to compute gflops call bench % stop_benchmark ( cmp_gflops ) !=============================================================================== !=============================================================================== ! start benchmark for method 2, same as above. call bench % start_benchmark ( 'matmul_m2' , 'my_matmul, C = matmul(A,B)' , [ p , p , p ]) do nl = 1 , bench % nloops ! call your function or subroutine or ... ! here is used another matmul C = 0.0_rk do i = 1 , p do j = 1 , p do k = 1 , p C ( i , j ) = C ( i , j ) + A ( i , k ) * B ( k , j ) end do end do end do end do call bench % stop_benchmark ( cmp_gflops ) !=============================================================================== ! you can add more methods ... end do ! end loop over p ! finalize the benchmark call bench % finalize () contains !=============================================================================== ! define an optional function to compute gflops function cmp_gflops ( argi , argr ) result ( gflops ) integer , dimension (:), intent ( in ) :: argi real ( rk ), dimension (:), intent ( in ), optional :: argr real ( rk ) :: gflops gflops = real ( argi ( 1 ), rk ) * real ( argi ( 2 ), rk ) * real ( argi ( 3 ), rk ) * 1.0e-9_rk end function cmp_gflops !=============================================================================== end program demo","tags":"","loc":"program/demo.html"},{"title":"forbenchmark_default.f90 – ForBenchmark","text":"Files dependent on this one sourcefile~~forbenchmark_default.f90~~AfferentGraph sourcefile~forbenchmark_default.f90 forbenchmark_default.f90 sourcefile~forbenchmark.f90 forbenchmark.f90 sourcefile~forbenchmark.f90->sourcefile~forbenchmark_default.f90 sourcefile~demo.f90 demo.f90 sourcefile~demo.f90->sourcefile~forbenchmark.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module forbenchmark_default use kinds use fortime , only : timer implicit none private public benchmark !=============================================================================== !> author: Seyed Ali Ghasemi type :: benchmark type ( timer ) :: time character (:), allocatable :: filename character (:), allocatable :: method character (:), allocatable :: description integer :: nloops integer , dimension (:), allocatable :: argi real ( rk ), dimension (:), allocatable :: argr real ( rk ) :: gflops contains procedure :: init procedure :: start_benchmark procedure :: stop_benchmark procedure , private :: write_benchmark procedure :: finalize end type benchmark !=============================================================================== contains !=============================================================================== !> author: Seyed Ali Ghasemi elemental impure subroutine init ( this , title , filename , nloops ) use , intrinsic :: iso_fortran_env , only : compiler_version , compiler_options class ( benchmark ), intent ( inout ) :: this character ( * ), intent ( in ), optional :: title character ( * ), intent ( in ), optional :: filename integer , intent ( in ), optional :: nloops integer :: nunit logical :: exist integer :: iostat if ( present ( filename )) then this % filename = trim ( filename // '.data' ) else this % filename = 'benchmark.data' endif if ( present ( nloops )) then if ( nloops <= 0 ) error stop 'nloops must be greater than zero.' this % nloops = nloops else this % nloops = 10 end if inquire ( file = this % filename , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename ) write ( nunit , '(a)' ) '-----------------------------------------------------' write ( nunit , '(a)' ) 'ForBenchmark - https://github.com/gha3mi/forbenchmark' write ( nunit , '(a)' ) '-----------------------------------------------------' write ( nunit , '(a)' ) '' if ( present ( title )) then write ( nunit , '(a)' ) trim ( title ) else write ( nunit , '(a)' ) 'ForBenchmark' endif write ( nunit , '(a)' ) current_date_and_time () write ( nunit , '(a)' ) '' write ( nunit , '(a,a)' ) 'compiler_version: ' , compiler_version () write ( nunit , '(a,a)' ) 'compiler_options: ' , compiler_options () write ( nunit , '(a)' ) '' write ( nunit , '(a)' ) & & '       METHOD        |& &         TIME         |& &        GFLOPS        |& &  NLOOPS  |& &   ARGS  ' close ( nunit ) end subroutine init !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine start_benchmark ( this , method , description , argi , argr ) use face class ( benchmark ), intent ( inout ) :: this character ( * ), intent ( in ) :: method integer , dimension (:), intent ( in ) :: argi real ( rk ), dimension (:), intent ( in ), optional :: argr character ( * ), intent ( in ), optional :: description this % description = description this % method = method this % argi = argi if ( present ( argr )) then this % argr = argr else if (. not . allocated ( this % argr )) allocate ( this % argr ( 0 )) endif if ( present ( description )) then print '(a,a,\" \",a,*(g0,1x))' ,& colorize ( 'Meth.: ' // this % method , color_fg = 'green' , style = 'bold_on' ),& colorize ( '; Des.: ' // this % description , color_fg = 'green_intense' ),& '; Args.:' ,& this % argi else print '(a,\" \",*(g0,1x))' ,& colorize ( 'Meth.: ' // this % method , color_fg = 'green' , style = 'bold_on' ), this % argi end if call this % time % timer_start () end subroutine start_benchmark !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine stop_benchmark ( this , flops ) interface impure function Fun ( argi , argr ) import rk integer , dimension (:), intent ( in ) :: argi real ( rk ), dimension (:), intent ( in ), optional :: argr real ( rk ) :: Fun end function Fun end interface procedure ( Fun ), optional :: flops class ( benchmark ), intent ( inout ) :: this call this % time % timer_stop ( message = ' Elapsed time :' , nloops = this % nloops ) if ( present ( flops )) then this % gflops = flops ( this % argi , this % argr ) / this % time % elapsed_time print '(a,f6.2,a)' , ' Performance  : ' , this % gflops , ' [GFLOPS]' else this % gflops = 0.0_rk endif print '(a)' , '' call this % write_benchmark () end subroutine stop_benchmark !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine write_benchmark ( this ) class ( benchmark ), intent ( inout ) :: this integer :: nunit character ( len = 55 ) :: fmt integer :: lm logical :: exist integer :: iostat lm = 20 - len_trim ( this % method ) write ( fmt , '(a,g0,a)' ) '(a,' , lm , 'x,3x,E20.14,3x,E20.14,3x,g8.0,3x,*(g8.0,3x))' inquire ( file = this % filename , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename , access = 'append' ) write ( nunit , fmt ) & this % method , this % time % elapsed_time , this % gflops , this % nloops , this % argi close ( nunit ) end subroutine write_benchmark !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi elemental impure subroutine finalize ( this ) class ( benchmark ), intent ( inout ) :: this integer :: nunit logical :: exist integer :: iostat inquire ( file = this % filename , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename , access = 'append' ) write ( nunit , '(a)' ) 'end of benchmark' close ( nunit ) if ( allocated ( this % filename )) deallocate ( this % filename ) if ( allocated ( this % method )) deallocate ( this % method ) if ( allocated ( this % description )) deallocate ( this % description ) if ( allocated ( this % argi )) deallocate ( this % argi ) if ( allocated ( this % argr )) deallocate ( this % argr ) print '(a)' , 'end of benchmark' end subroutine finalize !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure function current_date_and_time () result ( datetime ) character ( 21 ) :: datetime character ( 10 ) :: date character ( 8 ) :: time integer :: values ( 8 ) character ( 4 ) :: year character ( 2 ) :: month , day , hour , minute , second call date_and_time ( values = values ) write ( year , '(i4)' ) values ( 1 ) write ( month , '(i2)' ) values ( 2 ) write ( day , '(i2)' ) values ( 3 ) write ( hour , '(i2)' ) values ( 5 ) write ( minute , '(i2)' ) values ( 6 ) write ( second , '(i2)' ) values ( 7 ) date = year // '.' // month // '.' // day time = hour // ':' // minute // ':' // second datetime = date // ' - ' // time end function current_date_and_time !=============================================================================== end module forbenchmark_default","tags":"","loc":"sourcefile/forbenchmark_default.f90.html"},{"title":"forunittest.f90 – ForBenchmark","text":"Source Code module forunittest use kinds implicit none private public unit_test !=============================================================================== interface unit_test module procedure unit_test_r0 module procedure unit_test_r1 module procedure unit_test_r2 module procedure unit_test_compare_r1 module procedure unit_test_compare_i1 end interface unit_test !=============================================================================== contains !=============================================================================== !> author: Seyed Ali Ghasemi subroutine unit_test_r0 ( res , expected , tol , message ) real ( rk ), intent ( in ) :: res , expected real ( rk ), intent ( in ) :: tol character ( * ), intent ( in ) :: message logical :: condition integer :: lm character ( len = 20 ) :: fmt real ( rk ) :: rel_err lm = 46 - len_trim ( message ) write ( fmt , '(a,g0,a)' ) '(a,a' , lm , ',a)' if ( abs ( expected ) < tiny ( 0.0_rk )) then rel_err = abs ( res - expected ) else rel_err = abs ( res - expected ) / abs ( expected ) end if condition = rel_err < tol call print_message ( condition , message ) end subroutine unit_test_r0 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi subroutine unit_test_r1 ( res , expected , tol , message ) real ( rk ), intent ( in ), dimension (:) :: res , expected real ( rk ), intent ( in ) :: tol character ( * ), intent ( in ) :: message logical :: condition integer :: lm character ( len = 20 ) :: fmt real ( rk ) :: rel_err lm = 46 - len_trim ( message ) write ( fmt , '(a,g0,a)' ) '(a,a' , lm , ',a)' if ( norm2 ( expected ) < tiny ( 0.0_rk )) then rel_err = norm2 ( res - expected ) else rel_err = norm2 ( res - expected ) / norm2 ( expected ) end if condition = rel_err < tol call print_message ( condition , message ) end subroutine unit_test_r1 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi subroutine unit_test_r2 ( res , expected , tol , message ) real ( rk ), intent ( in ), dimension (:,:) :: res , expected real ( rk ), intent ( in ) :: tol character ( * ), intent ( in ) :: message logical :: condition integer :: lm character ( len = 20 ) :: fmt real ( rk ) :: rel_err lm = 46 - len_trim ( message ) write ( fmt , '(a,g0,a)' ) '(a,a' , lm , ',a)' if ( norm2 ( expected ) < tiny ( 0.0_rk )) then rel_err = norm2 ( res - expected ) else rel_err = norm2 ( res - expected ) / norm2 ( expected ) end if condition = rel_err < tol call print_message ( condition , message ) end subroutine unit_test_r2 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi subroutine unit_test_compare_r1 ( u , v , message ) real ( rk ), intent ( in ), dimension (:) :: u , v character ( * ), intent ( in ) :: message logical :: condition integer :: lm character ( len = 20 ) :: fmt real ( rk ) :: rel_err lm = 46 - len_trim ( message ) write ( fmt , '(a,g0,a)' ) '(a,a' , lm , ',a)' condition = any ( u == v ) call print_message ( condition , message ) end subroutine unit_test_compare_r1 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi subroutine unit_test_compare_i1 ( u , v , message ) integer , intent ( in ), dimension (:) :: u , v character ( * ), intent ( in ) :: message logical :: condition integer :: lm character ( len = 20 ) :: fmt real ( rk ) :: rel_err lm = 46 - len_trim ( message ) write ( fmt , '(a,g0,a)' ) '(a,a' , lm , ',a)' condition = any ( u == v ) call print_message ( condition , message ) end subroutine unit_test_compare_i1 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi subroutine print_message ( condition , message ) use face logical , intent ( in ) :: condition character ( * ), intent ( in ) :: message integer :: lm character ( len = 20 ) :: fmt lm = 55 - len_trim ( message ) write ( fmt , '(a,g0,a)' ) '(a,a' , lm , ',a)' if ( condition ) then print ( fmt ), message , colorize ( 'passed.' , color_fg = 'green' ) else print ( fmt ), message , colorize ( 'failed.' , color_fg = 'red' ) end if end subroutine print_message !=============================================================================== end module forunittest","tags":"","loc":"sourcefile/forunittest.f90.html"},{"title":"forbenchmark_coarray.f90 – ForBenchmark","text":"Files dependent on this one sourcefile~~forbenchmark_coarray.f90~~AfferentGraph sourcefile~forbenchmark_coarray.f90 forbenchmark_coarray.f90 sourcefile~forbenchmark.f90 forbenchmark.f90 sourcefile~forbenchmark.f90->sourcefile~forbenchmark_coarray.f90 sourcefile~demo.f90 demo.f90 sourcefile~demo.f90->sourcefile~forbenchmark.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module forbenchmark_coarray #if defined(USE_COARRAY) use kinds use fortime , only : timer implicit none private public benchmark !=============================================================================== !> author: Seyed Ali Ghasemi type :: benchmark type ( timer ), allocatable :: time [:] character (:), allocatable :: filename character (:), allocatable :: method character (:), allocatable :: description integer :: nloops integer , dimension (:), allocatable :: argi real ( rk ), dimension (:), allocatable :: argr real ( rk ), allocatable :: gflops [:] real ( rk ) :: elapsed_time_average real ( rk ) :: gflops_total contains procedure :: init procedure :: start_benchmark procedure :: stop_benchmark procedure , private :: write_benchmark procedure :: finalize end type benchmark !=============================================================================== contains !=============================================================================== !> author: Seyed Ali Ghasemi elemental impure subroutine init ( this , title , filename , nloops ) use , intrinsic :: iso_fortran_env , only : compiler_version , compiler_options class ( benchmark ), intent ( inout ) :: this character ( * ), intent ( in ), optional :: title character ( * ), intent ( in ), optional :: filename integer , intent ( in ), optional :: nloops integer :: nunit logical :: exist integer :: iostat character ( 10 ) :: im_chr write ( im_chr , '(i0)' ) this_image () if ( present ( filename )) then this % filename = trim ( filename // '_im' // trim ( im_chr ) // '.data' ) else this % filename = trim ( 'benchmark' // '_im' // trim ( im_chr ) // '.data' ) end if if ( present ( nloops )) then if ( nloops <= 0 ) error stop 'nloops must be greater than zero.' this % nloops = nloops else this % nloops = 10 end if allocate ( this % time [ * ]) allocate ( this % gflops [ * ]) inquire ( file = this % filename , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename ) write ( nunit , '(a)' ) '-----------------------------------------------------' write ( nunit , '(a)' ) 'ForBenchmark - https://github.com/gha3mi/forbenchmark' write ( nunit , '(a)' ) '-----------------------------------------------------' write ( nunit , '(a)' ) '' if ( present ( title )) then write ( nunit , '(a)' ) trim ( title ) else write ( nunit , '(a)' ) 'ForBenchmark' end if write ( nunit , '(a)' ) current_date_and_time () write ( nunit , '(a)' ) '' write ( nunit , '(a,a)' ) 'compiler_version: ' , compiler_version () write ( nunit , '(a,a)' ) 'compiler_options: ' , compiler_options () write ( nunit , '(a)' ) '' write ( nunit , '(a)' ) & & '       METHOD        |& &      TIME(avg)       |& &     GFLOPS(tot)      |& &     TIME(image)      |& &    GFLOPS(image)     |& &  NLOOPS  |& &   ARGS  ' close ( nunit ) end subroutine init !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine start_benchmark ( this , method , description , argi , argr ) use face class ( benchmark ), intent ( inout ) :: this character ( * ), intent ( in ) :: method integer , dimension (:), intent ( in ) :: argi real ( rk ), dimension (:), intent ( in ), optional :: argr character ( * ), intent ( in ), optional :: description this % description = description this % method = method this % argi = argi if ( present ( argr )) then this % argr = argr else if (. not . allocated ( this % argr )) allocate ( this % argr ( 0 )) endif sync all if ( present ( description ) . and . this_image () == 1 ) then print '(a,a,\" \",a,*(g0,1x))' ,& colorize ( 'Meth.: ' // this % method , color_fg = 'green' , style = 'bold_on' ),& colorize ( '; Des.: ' // this % description , color_fg = 'green_intense' ),& '; Args.:' ,& this % argi elseif (. not . present ( description ) . and . this_image () == 1 ) then print '(a,\" \",*(g0,1x))' ,& colorize ( 'Meth.: ' // this % method , color_fg = 'green' , style = 'bold_on' ), this % argi end if call this % time [ this_image ()]% timer_start () end subroutine start_benchmark !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine stop_benchmark ( this , flops ) use face interface impure function Fun ( argi , argr ) import rk integer , dimension (:), intent ( in ) :: argi real ( rk ), dimension (:), intent ( in ), optional :: argr real ( rk ) :: Fun end function Fun end interface procedure ( Fun ), optional :: flops class ( benchmark ), intent ( inout ) :: this real ( rk ) :: elapsed_time_average real ( rk ) :: gflops_total integer :: i call this % time [ this_image ()]% timer_stop ( message = ' Elapsed time :' , nloops = this % nloops ) if ( present ( flops )) then this % gflops [ this_image ()] = flops ( this % argi , this % argr ) / this % time [ this_image ()]% elapsed_time print '(a,f6.2,a)' , ' Performance  : ' , this % gflops [ this_image ()], ' [GFLOPS/image]' else this % gflops [ this_image ()] = 0.0_rk end if sync all if ( this_image () == 1 ) then elapsed_time_average = 0.0_rk if ( present ( flops )) gflops_total = 0.0_rk do i = 1 , num_images () elapsed_time_average = elapsed_time_average + this % time [ i ]% elapsed_time if ( present ( flops )) gflops_total = gflops_total + this % gflops [ i ] end do elapsed_time_average = elapsed_time_average / num_images () print '(a,f7.3,a)' , colorize ( ' Elapsed time (average) :' , color_fg = 'blue' ),& elapsed_time_average , ' [s]' if ( present ( flops )) print '(a,f6.2,a)' , colorize ( ' Performance  (total)   : ' , color_fg = 'cyan' ),& gflops_total , ' [GFLOPS]' print '(a)' , '' end if call co_broadcast ( elapsed_time_average , 1 ) if ( present ( flops )) call co_broadcast ( gflops_total , 1 ) this % elapsed_time_average = elapsed_time_average if ( present ( flops )) then this % gflops_total = gflops_total else this % gflops_total = 0.0_rk end if call this % write_benchmark () end subroutine stop_benchmark !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine write_benchmark ( this ) class ( benchmark ), intent ( inout ) :: this integer :: nunit character ( len = 75 ) :: fmt integer :: lm logical :: exist integer :: iostat lm = 20 - len_trim ( this % method ) write ( fmt , '(a,g0,a)' ) '(a,' , lm , 'x,3x,E20.14,3x,E20.14,3x,E20.14,3x,E20.14,3x,g8.0,3x,*(g8.0,3x))' inquire ( file = this % filename , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename , access = 'append' ) write ( nunit , fmt ) & this % method ,& this % elapsed_time_average ,& this % gflops_total ,& this % time [ this_image ()]% elapsed_time ,& this % gflops [ this_image ()],& this % nloops ,& this % argi close ( nunit ) end subroutine write_benchmark !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi elemental impure subroutine finalize ( this ) class ( benchmark ), intent ( inout ) :: this integer :: nunit logical :: exist integer :: iostat inquire ( file = this % filename , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename , access = 'append' ) write ( nunit , '(a)' ) 'end of benchmark' close ( nunit ) if ( allocated ( this % filename )) deallocate ( this % filename ) if ( allocated ( this % method )) deallocate ( this % method ) if ( allocated ( this % description )) deallocate ( this % description ) if ( allocated ( this % argi )) deallocate ( this % argi ) if ( allocated ( this % argr )) deallocate ( this % argr ) if ( allocated ( this % time )) deallocate ( this % time ) if ( allocated ( this % gflops )) deallocate ( this % gflops ) if ( this_image () == 1 ) print '(a)' , 'end of benchmark' end subroutine finalize !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure function current_date_and_time () result ( datetime ) character ( 21 ) :: datetime character ( 10 ) :: date character ( 8 ) :: time integer :: values ( 8 ) character ( 4 ) :: year character ( 2 ) :: month , day , hour , minute , second call date_and_time ( values = values ) write ( year , '(i4)' ) values ( 1 ) write ( month , '(i2)' ) values ( 2 ) write ( day , '(i2)' ) values ( 3 ) write ( hour , '(i2)' ) values ( 5 ) write ( minute , '(i2)' ) values ( 6 ) write ( second , '(i2)' ) values ( 7 ) date = year // '.' // month // '.' // day time = hour // ':' // minute // ':' // second datetime = date // ' - ' // time end function current_date_and_time !=============================================================================== #endif end module forbenchmark_coarray","tags":"","loc":"sourcefile/forbenchmark_coarray.f90.html"},{"title":"forbenchmark.f90 – ForBenchmark","text":"This file depends on sourcefile~~forbenchmark.f90~~EfferentGraph sourcefile~forbenchmark.f90 forbenchmark.f90 sourcefile~forbenchmark_coarray.f90 forbenchmark_coarray.f90 sourcefile~forbenchmark.f90->sourcefile~forbenchmark_coarray.f90 sourcefile~forbenchmark_default.f90 forbenchmark_default.f90 sourcefile~forbenchmark.f90->sourcefile~forbenchmark_default.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~forbenchmark.f90~~AfferentGraph sourcefile~forbenchmark.f90 forbenchmark.f90 sourcefile~demo.f90 demo.f90 sourcefile~demo.f90->sourcefile~forbenchmark.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module forbenchmark #if defined(USE_COARRAY) use forbenchmark_coarray #else use forbenchmark_default #endif public benchmark end module forbenchmark","tags":"","loc":"sourcefile/forbenchmark.f90.html"},{"title":"demo.f90 – ForBenchmark","text":"This file depends on sourcefile~~demo.f90~~EfferentGraph sourcefile~demo.f90 demo.f90 sourcefile~forbenchmark.f90 forbenchmark.f90 sourcefile~demo.f90->sourcefile~forbenchmark.f90 sourcefile~forbenchmark_coarray.f90 forbenchmark_coarray.f90 sourcefile~forbenchmark.f90->sourcefile~forbenchmark_coarray.f90 sourcefile~forbenchmark_default.f90 forbenchmark_default.f90 sourcefile~forbenchmark.f90->sourcefile~forbenchmark_default.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! this is a demo program for forbenchmark. ! can be used for serial or coarray benchmarks. ! use -DUSE_COARRAY to compile for coarray benchmarks. program demo use kinds , only : rk ! use -DREAL32 or -DREAL64 to switch between real32 and real64, default is real64 use forbenchmark , only : benchmark ! forbenchmark module implicit none ! benchmark object type ( benchmark ) :: bench ! define your variables here real ( rk ), dimension (:,:), allocatable :: A , B , C integer :: nl , p , i , j , k ! initialize the benchmark ! title: optional ! filename: optional. make sure directory exists ! nloops: optional. number of loops for each benchmark. default is 10. call bench % init ( title = 'MatMul Benchmark' , filename = 'results/demo_matmul' , nloops = 10 ) ! start the benchmark do p = 100 , 400 , 100 ! loop over problem size !=============================================================================== ! allocate and initialize your variables here if ( allocated ( A )) deallocate ( A ) if ( allocated ( B )) deallocate ( B ) if ( allocated ( C )) deallocate ( C ) allocate ( A ( p , p )) allocate ( B ( p , p )) allocate ( C ( p , p ), source = 0.0_rk ) call random_number ( A ) call random_number ( B ) !=============================================================================== !=============================================================================== ! start benchmark for method 1 ! method is a string to identify the method ! description is optional ! argi is an integer array of arguments, to write in the output file ! argr is a real array of arguments, optional call bench % start_benchmark ( method = 'matmul_m1' , description = 'intrinsic, C = matmul(A,B)' , argi = [ p , p , p ]) ! loop over nloops do nl = 1 , bench % nloops ! call your function or subroutine or ... ! here is used intrinsic matmul C = matmul ( A , B ) end do ! stop benchmark for method 1 ! cmp_gflops is an optional function to compute gflops call bench % stop_benchmark ( cmp_gflops ) !=============================================================================== !=============================================================================== ! start benchmark for method 2, same as above. call bench % start_benchmark ( 'matmul_m2' , 'my_matmul, C = matmul(A,B)' , [ p , p , p ]) do nl = 1 , bench % nloops ! call your function or subroutine or ... ! here is used another matmul C = 0.0_rk do i = 1 , p do j = 1 , p do k = 1 , p C ( i , j ) = C ( i , j ) + A ( i , k ) * B ( k , j ) end do end do end do end do call bench % stop_benchmark ( cmp_gflops ) !=============================================================================== ! you can add more methods ... end do ! end loop over p ! finalize the benchmark call bench % finalize () contains !=============================================================================== ! define an optional function to compute gflops function cmp_gflops ( argi , argr ) result ( gflops ) integer , dimension (:), intent ( in ) :: argi real ( rk ), dimension (:), intent ( in ), optional :: argr real ( rk ) :: gflops gflops = real ( argi ( 1 ), rk ) * real ( argi ( 2 ), rk ) * real ( argi ( 3 ), rk ) * 1.0e-9_rk end function cmp_gflops !=============================================================================== end program demo","tags":"","loc":"sourcefile/demo.f90.html"}]}