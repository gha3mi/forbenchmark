var tipuesearch = {"pages":[{"title":" ForBenchmark ","text":"ForBenchmark ForBenchmark : A Fortran library for benchmarking (with support for coarrays). Usage use forbenchmark type ( benchmark ) :: bench ! initialize the benchmark call bench % init ( nmarks ) ! start benchmark call bench % start_benchmark ( imark , method ) ! loop over nloops do nl = 1 , bench % nloops ! call your function or subroutine or ... end do ! stop benchmark call bench % stop_benchmark ( imark ) ! finalize the benchmark call bench % finalize () See example/demo.f90 for a complete example. fpm dependency To use ForBenchmark as a dependency in your fpm project, include the following line in your fpm.toml file: [dependencies] forbenchmark = { git = \"https://github.com/gha3mi/forbenchmark.git\" } How to Run the Demo Clone the repository: Clone the ForBenchmark repository from GitHub using: git clone https://github.com/gha3mi/forbenchmark.git cd forbenchmark Run the demo: For non-coarray benchmarking: fpm run --example demo For coarray programs benchmarking using the Intel Fortran compiler: fpm run --example demo --compiler ifx --flag \"-coarray -coarray-num-images=4 -DUSE_COARRAY\" fpm run --example demo --compiler ifort --flag \"-coarray -coarray-num-images=4 -DUSE_COARRAY\" After execution, the results will be displayed in the terminal and stored in the 'results' folder. See results/demo.data , results/demo_im1.data for instance. Visualizing demo results: To visualize benchmarking results, run the following commands in Python, specifying the relevant data files as arguments: python results/plot.py demo.data The output includes graphical representations of benchmarking metrics: For Coarray: python results/plot_co.py demo_co.data\npython results/plot_im.py demo_im1.data The outputs can be found in the results directory. TODO [ ] Add settings to set units. [ ] Add benchmarks for matmul, dot ... [ ] Add MPI module. [x] Add plot_co.py similar to plot.py. [x] Add CI_test.yml API documentation The most up-to-date API documentation for the main branch is available here .\nTo generate the API documentation for ForBenchmark using ford run the following\ncommand: ford ford.yml Contributing Contributions to ForBenchmark are welcome!\nIf you find any issues or would like to suggest improvements, please open an issue. Developer Info Seyed Ali Ghasemi","tags":"home","loc":"index.html"},{"title":"mark – ForBenchmark ","text":"type, private :: mark Inherits type~~mark~2~~InheritsGraph type~mark~2 mark timer timer type~mark~2->timer time Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~mark~2~~InheritedByGraph type~mark~2 mark type~benchmark~2 benchmark type~benchmark~2->type~mark~2 marks Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: method character(len=:), public, allocatable :: description type(timer), public :: time real(kind=rk), public :: speedup real(kind=rk), public :: flops Type-Bound Procedures procedure, private :: finalize_mark private pure elemental subroutine finalize_mark (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( mark ), intent(inout) :: this Source Code type :: mark !! author: Seyed Ali Ghasemi character (:), allocatable :: method character (:), allocatable :: description type ( timer ) :: time real ( rk ) :: speedup real ( rk ) :: flops contains procedure , private :: finalize_mark end type mark","tags":"","loc":"type/mark~2.html"},{"title":"benchmark – ForBenchmark ","text":"type, public :: benchmark Inherits type~~benchmark~2~~InheritsGraph type~benchmark~2 benchmark type~mark~2 mark type~benchmark~2->type~mark~2 marks timer timer type~mark~2->timer time Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( mark ), public, dimension(:), allocatable :: marks character(len=:), public, allocatable :: filename integer, public :: nloops integer, public, dimension(:), allocatable :: argi real(kind=rk), public, dimension(:), allocatable :: argr Type-Bound Procedures procedure, public :: init private impure elemental subroutine init (this, nmarks, title, filename, nloops) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this integer, intent(in) :: nmarks character(len=*), intent(in), optional :: title character(len=*), intent(in), optional :: filename integer, intent(in), optional :: nloops procedure, public :: start_benchmark private impure subroutine start_benchmark (this, imark, method, description, argi, argr) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this integer, intent(in) :: imark character(len=*), intent(in) :: method character(len=*), intent(in), optional :: description integer, intent(in), optional, dimension(:) :: argi real(kind=rk), intent(in), optional, dimension(:) :: argr procedure, public :: stop_benchmark private impure subroutine stop_benchmark (this, imark, flops) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this integer, intent(in) :: imark procedure(Fun), optional :: flops procedure, private :: write_benchmark private impure subroutine write_benchmark (this, imark) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this integer, intent(in) :: imark procedure, public :: finalize private impure elemental subroutine finalize (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Source Code type :: benchmark !! author: Seyed Ali Ghasemi type ( mark ), dimension (:), allocatable :: marks character (:), allocatable :: filename integer :: nloops integer , dimension (:), allocatable :: argi real ( rk ), dimension (:), allocatable :: argr contains procedure :: init procedure :: start_benchmark procedure :: stop_benchmark procedure , private :: write_benchmark procedure :: finalize end type benchmark","tags":"","loc":"type/benchmark~2.html"},{"title":"mark_co – ForBenchmark ","text":"type, private :: mark_co Inherits type~~mark_co~~InheritsGraph type~mark_co mark_co timer timer type~mark_co->timer time Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~mark_co~~InheritedByGraph type~mark_co mark_co type~benchmark benchmark type~benchmark->type~mark_co marks_co Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(timer), public :: time real(kind=rk), public :: flops Source Code type :: mark_co !! author: Seyed Ali Ghasemi type ( timer ) :: time real ( rk ) :: flops end type mark_co","tags":"","loc":"type/mark_co.html"},{"title":"mark – ForBenchmark ","text":"type, private :: mark Inherited by type~~mark~~InheritedByGraph type~mark mark type~benchmark benchmark type~benchmark->type~mark marks Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: method character(len=:), public, allocatable :: description real(kind=rk), public :: elapsed_time_min real(kind=rk), public :: elapsed_time_average real(kind=rk), public :: elapsed_time_max real(kind=rk), public :: flops_total real(kind=rk), public :: speedup_max_total Type-Bound Procedures procedure, private :: finalize_mark private pure elemental subroutine finalize_mark (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( mark ), intent(inout) :: this Source Code type :: mark !! author: Seyed Ali Ghasemi character (:), allocatable :: method character (:), allocatable :: description real ( rk ) :: elapsed_time_min real ( rk ) :: elapsed_time_average real ( rk ) :: elapsed_time_max real ( rk ) :: flops_total real ( rk ) :: speedup_max_total contains procedure , private :: finalize_mark end type mark","tags":"","loc":"type/mark.html"},{"title":"benchmark – ForBenchmark ","text":"type, public :: benchmark Inherits type~~benchmark~~InheritsGraph type~benchmark benchmark type~mark mark type~benchmark->type~mark marks type~mark_co mark_co type~benchmark->type~mark_co marks_co timer timer type~mark_co->timer time Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( mark_co ), public, dimension(:), allocatable :: marks_co [:] type( mark ), public, dimension(:), allocatable :: marks character(len=:), public, allocatable :: filename character(len=:), public, allocatable :: filename_image integer, public :: nloops integer, public, dimension(:), allocatable :: argi real(kind=rk), public, dimension(:), allocatable :: argr Type-Bound Procedures procedure, public :: init private impure elemental subroutine init (this, nmarks, title, filename, nloops) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this integer, intent(in) :: nmarks character(len=*), intent(in), optional :: title character(len=*), intent(in), optional :: filename integer, intent(in), optional :: nloops procedure, public :: start_benchmark private impure subroutine start_benchmark (this, imark, method, description, argi, argr) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this integer, intent(in) :: imark character(len=*), intent(in) :: method character(len=*), intent(in), optional :: description integer, intent(in), optional, dimension(:) :: argi real(kind=rk), intent(in), optional, dimension(:) :: argr procedure, public :: stop_benchmark private impure subroutine stop_benchmark (this, imark, flops) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this integer, intent(in) :: imark procedure(Fun), optional :: flops procedure, private :: write_benchmark private impure subroutine write_benchmark (this, imark) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this integer, intent(in) :: imark procedure, public :: finalize private impure elemental subroutine finalize (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Source Code type :: benchmark !! author: Seyed Ali Ghasemi type ( mark_co ), dimension (:), allocatable :: marks_co [:] type ( mark ), dimension (:), allocatable :: marks character (:), allocatable :: filename character (:), allocatable :: filename_image integer :: nloops integer , dimension (:), allocatable :: argi real ( rk ), dimension (:), allocatable :: argr contains procedure :: init procedure :: start_benchmark procedure :: stop_benchmark procedure , private :: write_benchmark procedure :: finalize end type benchmark","tags":"","loc":"type/benchmark.html"},{"title":"cmp_gflops – ForBenchmark","text":"function cmp_gflops(argi, argr) result(gflops) Arguments Type Intent Optional Attributes Name integer, intent(in), optional, dimension(:) :: argi real(kind=rk), intent(in), optional, dimension(:) :: argr Return Value real(kind=rk) Source Code function cmp_gflops ( argi , argr ) result ( gflops ) integer , dimension (:), intent ( in ), optional :: argi real ( rk ), dimension (:), intent ( in ), optional :: argr real ( rk ) :: gflops gflops = real ( argi ( 1 ), rk ) * real ( argi ( 2 ), rk ) * real ( argi ( 3 ), rk ) * 1.0e-9_rk end function cmp_gflops","tags":"","loc":"proc/cmp_gflops.html"},{"title":"current_date_and_time – ForBenchmark","text":"private impure function current_date_and_time() result(datetime) Arguments None Return Value character(len=21) Called by proc~~current_date_and_time~~CalledByGraph proc~current_date_and_time forbenchmark_default::current_date_and_time proc~init forbenchmark_default::benchmark%init proc~init->proc~current_date_and_time program~demo demo program~demo->proc~init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure function current_date_and_time () result ( datetime ) !! author: Seyed Ali Ghasemi character ( 21 ) :: datetime character ( 10 ) :: date character ( 8 ) :: time integer :: values ( 8 ) character ( 4 ) :: year character ( 2 ) :: month , day , hour , minute , second call date_and_time ( values = values ) write ( year , '(i4)' ) values ( 1 ) write ( month , '(i2)' ) values ( 2 ) write ( day , '(i2)' ) values ( 3 ) write ( hour , '(i2)' ) values ( 5 ) write ( minute , '(i2)' ) values ( 6 ) write ( second , '(i2)' ) values ( 7 ) date = year // '.' // month // '.' // day time = hour // ':' // minute // ':' // second datetime = date // ' - ' // time end function current_date_and_time","tags":"","loc":"proc/current_date_and_time.html"},{"title":"init – ForBenchmark","text":"private impure elemental subroutine init(this, nmarks, title, filename, nloops) Uses iso_fortran_env proc~~init~~UsesGraph proc~init forbenchmark_default::benchmark%init iso_fortran_env iso_fortran_env proc~init->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type Bound benchmark Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this integer, intent(in) :: nmarks character(len=*), intent(in), optional :: title character(len=*), intent(in), optional :: filename integer, intent(in), optional :: nloops Calls proc~~init~~CallsGraph proc~init forbenchmark_default::benchmark%init proc~current_date_and_time forbenchmark_default::current_date_and_time proc~init->proc~current_date_and_time Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~init~~CalledByGraph proc~init forbenchmark_default::benchmark%init program~demo demo program~demo->proc~init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental impure subroutine init ( this , nmarks , title , filename , nloops ) !! author: Seyed Ali Ghasemi use , intrinsic :: iso_fortran_env , only : compiler_version , compiler_options class ( benchmark ), intent ( inout ) :: this integer , intent ( in ) :: nmarks character ( * ), intent ( in ), optional :: title character ( * ), intent ( in ), optional :: filename integer , intent ( in ), optional :: nloops integer :: nunit integer :: iostat if ( nmarks <= 0 ) error stop 'nmarks must be greater than zero.' allocate ( this % marks ( nmarks )) if ( present ( filename )) then this % filename = trim ( filename // '.data' ) else this % filename = 'benchmark.data' endif if ( present ( nloops )) then if ( nloops <= 0 ) error stop 'nloops must be greater than zero.' this % nloops = nloops else this % nloops = 10 end if inquire ( file = this % filename , iostat = iostat ) if ( iostat /= 0 ) then error stop 'file ' // trim ( this % filename ) // ' cannot be accessed.' end if open ( newunit = nunit , file = this % filename ) write ( nunit , '(a)' ) '-----------------------------------------------------' write ( nunit , '(a)' ) 'ForBenchmark - https://github.com/gha3mi/forbenchmark' write ( nunit , '(a)' ) '-----------------------------------------------------' write ( nunit , '(a)' ) '' if ( present ( title )) then write ( nunit , '(a)' ) trim ( title ) else write ( nunit , '(a)' ) 'ForBenchmark' endif write ( nunit , '(a)' ) current_date_and_time () write ( nunit , '(a)' ) '' write ( nunit , '(a,a)' ) 'compiler_version: ' , compiler_version () write ( nunit , '(a,a)' ) 'compiler_options: ' , compiler_options () write ( nunit , '(a)' ) '' write ( nunit , '(a)' ) '' write ( nunit , '(a)' ) & & '       METHOD        |& &   SPEEDUP    |& &         TIME         |& &        GFLOPS        |& &  NLOOPS  |& &   ARGI  ' close ( nunit ) end subroutine init","tags":"","loc":"proc/init.html"},{"title":"start_benchmark – ForBenchmark","text":"private impure subroutine start_benchmark(this, imark, method, description, argi, argr) Uses face proc~~start_benchmark~~UsesGraph proc~start_benchmark forbenchmark_default::benchmark%start_benchmark face face proc~start_benchmark->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type Bound benchmark Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this integer, intent(in) :: imark character(len=*), intent(in) :: method character(len=*), intent(in), optional :: description integer, intent(in), optional, dimension(:) :: argi real(kind=rk), intent(in), optional, dimension(:) :: argr Calls proc~~start_benchmark~~CallsGraph proc~start_benchmark forbenchmark_default::benchmark%start_benchmark colorize colorize proc~start_benchmark->colorize timer_start timer_start proc~start_benchmark->timer_start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~start_benchmark~~CalledByGraph proc~start_benchmark forbenchmark_default::benchmark%start_benchmark program~demo demo program~demo->proc~start_benchmark Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine start_benchmark ( this , imark , method , description , argi , argr ) !! author: Seyed Ali Ghasemi use face class ( benchmark ), intent ( inout ) :: this integer , intent ( in ) :: imark character ( * ), intent ( in ) :: method integer , dimension (:), intent ( in ), optional :: argi real ( rk ), dimension (:), intent ( in ), optional :: argr character ( * ), intent ( in ), optional :: description if ( imark <= 0 . or . imark > size ( this % marks )) error stop 'imark is out of range.' this % marks ( imark )% description = description this % marks ( imark )% method = method if ( present ( argi )) then this % argi = argi else if (. not . allocated ( this % argi )) allocate ( this % argi ( 0 )) endif if ( present ( argr )) then this % argr = argr else if (. not . allocated ( this % argr )) allocate ( this % argr ( 0 )) endif if ( present ( description ) . and . present ( argi )) then print '(a,a,\" \",a,*(g0,1x))' ,& colorize ( 'Meth.: ' // this % marks ( imark )% method , color_fg = 'green' , style = 'bold_on' ),& colorize ( '; Des.: ' // this % marks ( imark )% description , color_fg = 'green_intense' ),& '; Argi.:' ,& this % argi elseif ( present ( description ) . and . . not . present ( argi )) then print '(a,a,\" \",a)' ,& colorize ( 'Meth.: ' // this % marks ( imark )% method , color_fg = 'green' , style = 'bold_on' ),& colorize ( '; Des.: ' // this % marks ( imark )% description , color_fg = 'green_intense' ) elseif (. not . present ( description ) . and . present ( argi )) then print '(a,a,*(g0,1x))' ,& colorize ( 'Meth.: ' // this % marks ( imark )% method , color_fg = 'green' , style = 'bold_on' ),& '; Argi.:' ,& this % argi else print '(a)' , colorize ( 'Meth.: ' // this % marks ( imark )% method , color_fg = 'green' , style = 'bold_on' ) end if call this % marks ( imark )% time % timer_start () end subroutine start_benchmark","tags":"","loc":"proc/start_benchmark.html"},{"title":"stop_benchmark – ForBenchmark","text":"private impure subroutine stop_benchmark(this, imark, flops) Type Bound benchmark Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this integer, intent(in) :: imark procedure(Fun), optional :: flops Calls proc~~stop_benchmark~~CallsGraph proc~stop_benchmark forbenchmark_default::benchmark%stop_benchmark proc~write_benchmark forbenchmark_default::benchmark%write_benchmark proc~stop_benchmark->proc~write_benchmark timer_stop timer_stop proc~stop_benchmark->timer_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~stop_benchmark~~CalledByGraph proc~stop_benchmark forbenchmark_default::benchmark%stop_benchmark program~demo demo program~demo->proc~stop_benchmark Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine stop_benchmark ( this , imark , flops ) !! author: Seyed Ali Ghasemi interface impure function Fun ( argi , argr ) import rk integer , dimension (:), intent ( in ), optional :: argi real ( rk ), dimension (:), intent ( in ), optional :: argr real ( rk ) :: Fun end function Fun end interface procedure ( Fun ), optional :: flops class ( benchmark ), intent ( inout ) :: this integer , intent ( in ) :: imark if ( imark <= 0 . or . imark > size ( this % marks )) error stop 'imark is out of range.' call this % marks ( imark )% time % timer_stop ( message = ' Elapsed time :' , nloops = this % nloops ) this % marks ( imark )% speedup = this % marks ( imark )% time % elapsed_time / this % marks ( 1 )% time % elapsed_time if ( present ( flops )) then print '(a,f7.3,a)' , ' Speedup      :' , this % marks ( imark )% speedup , ' [-]' this % marks ( imark )% flops = flops ( this % argi , this % argr ) / this % marks ( imark )% time % elapsed_time print '(a,f7.3,a)' , ' Performance  :' , this % marks ( imark )% flops , ' [GFLOPS]' else this % marks ( imark )% flops = 0.0_rk endif print '(a)' , '' call this % write_benchmark ( imark ) end subroutine stop_benchmark","tags":"","loc":"proc/stop_benchmark.html"},{"title":"write_benchmark – ForBenchmark","text":"private impure subroutine write_benchmark(this, imark) Type Bound benchmark Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this integer, intent(in) :: imark Called by proc~~write_benchmark~~CalledByGraph proc~write_benchmark forbenchmark_default::benchmark%write_benchmark proc~stop_benchmark forbenchmark_default::benchmark%stop_benchmark proc~stop_benchmark->proc~write_benchmark program~demo demo program~demo->proc~stop_benchmark Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine write_benchmark ( this , imark ) !! author: Seyed Ali Ghasemi class ( benchmark ), intent ( inout ) :: this integer , intent ( in ) :: imark integer :: nunit character ( len = 65 ) :: fmt integer :: lm logical :: exist integer :: iostat if ( imark <= 0 . or . imark > size ( this % marks )) error stop 'imark is out of range.' inquire ( file = this % filename , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename , access = 'append' ) lm = 20 - len_trim ( this % marks ( imark )% method ) write ( fmt , '(a,g0,a)' ) '(a,' , lm , 'x,3x,F12.6,3x,E20.14,3x,E20.14,3x,g8.0,3x,*(g8.0,3x))' write ( nunit , fmt ) & this % marks ( imark )% method ,& this % marks ( imark )% speedup ,& this % marks ( imark )% time % elapsed_time ,& this % marks ( imark )% flops ,& this % nloops ,& this % argi close ( nunit ) end subroutine write_benchmark","tags":"","loc":"proc/write_benchmark.html"},{"title":"finalize_mark – ForBenchmark","text":"private pure elemental subroutine finalize_mark(this) Type Bound mark Arguments Type Intent Optional Attributes Name class( mark ), intent(inout) :: this Called by proc~~finalize_mark~~CalledByGraph proc~finalize_mark forbenchmark_default::mark%finalize_mark proc~finalize forbenchmark_default::benchmark%finalize proc~finalize->proc~finalize_mark program~demo demo program~demo->proc~finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental pure subroutine finalize_mark ( this ) !! author: Seyed Ali Ghasemi class ( mark ), intent ( inout ) :: this if ( allocated ( this % method )) deallocate ( this % method ) if ( allocated ( this % description )) deallocate ( this % description ) end subroutine finalize_mark","tags":"","loc":"proc/finalize_mark.html"},{"title":"finalize – ForBenchmark","text":"private impure elemental subroutine finalize(this) Type Bound benchmark Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Calls proc~~finalize~~CallsGraph proc~finalize forbenchmark_default::benchmark%finalize proc~finalize_mark forbenchmark_default::mark%finalize_mark proc~finalize->proc~finalize_mark Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~finalize~~CalledByGraph proc~finalize forbenchmark_default::benchmark%finalize program~demo demo program~demo->proc~finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental impure subroutine finalize ( this ) !! author: Seyed Ali Ghasemi class ( benchmark ), intent ( inout ) :: this integer :: nunit logical :: exist integer :: iostat inquire ( file = this % filename , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename , access = 'append' ) write ( nunit , '(a)' ) 'end of benchmark' close ( nunit ) call this % marks (:)% finalize_mark () if ( allocated ( this % filename )) deallocate ( this % filename ) if ( allocated ( this % argi )) deallocate ( this % argi ) if ( allocated ( this % argr )) deallocate ( this % argr ) print '(a)' , 'end of benchmark' end subroutine finalize","tags":"","loc":"proc/finalize.html"},{"title":"current_date_and_time – ForBenchmark","text":"private impure function current_date_and_time() result(datetime) Arguments None Return Value character(len=21) Called by proc~~current_date_and_time~2~~CalledByGraph proc~current_date_and_time~2 forbenchmark_coarray::current_date_and_time proc~init~2 forbenchmark_coarray::benchmark%init proc~init~2->proc~current_date_and_time~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure function current_date_and_time () result ( datetime ) !! author: Seyed Ali Ghasemi character ( 21 ) :: datetime character ( 10 ) :: date character ( 8 ) :: time integer :: values ( 8 ) character ( 4 ) :: year character ( 2 ) :: month , day , hour , minute , second call date_and_time ( values = values ) write ( year , '(i4)' ) values ( 1 ) write ( month , '(i2)' ) values ( 2 ) write ( day , '(i2)' ) values ( 3 ) write ( hour , '(i2)' ) values ( 5 ) write ( minute , '(i2)' ) values ( 6 ) write ( second , '(i2)' ) values ( 7 ) date = year // '.' // month // '.' // day time = hour // ':' // minute // ':' // second datetime = date // ' - ' // time end function current_date_and_time","tags":"","loc":"proc/current_date_and_time~2.html"},{"title":"init – ForBenchmark","text":"private impure elemental subroutine init(this, nmarks, title, filename, nloops) Uses iso_fortran_env proc~~init~2~~UsesGraph proc~init~2 forbenchmark_coarray::benchmark%init iso_fortran_env iso_fortran_env proc~init~2->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type Bound benchmark Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this integer, intent(in) :: nmarks character(len=*), intent(in), optional :: title character(len=*), intent(in), optional :: filename integer, intent(in), optional :: nloops Calls proc~~init~2~~CallsGraph proc~init~2 forbenchmark_coarray::benchmark%init proc~current_date_and_time~2 forbenchmark_coarray::current_date_and_time proc~init~2->proc~current_date_and_time~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental impure subroutine init ( this , nmarks , title , filename , nloops ) !! author: Seyed Ali Ghasemi use , intrinsic :: iso_fortran_env , only : compiler_version , compiler_options class ( benchmark ), intent ( inout ) :: this integer , intent ( in ) :: nmarks character ( * ), intent ( in ), optional :: title character ( * ), intent ( in ), optional :: filename integer , intent ( in ), optional :: nloops integer :: nunit integer :: iostat character ( 10 ) :: im_chr if ( nmarks <= 0 ) error stop 'nmarks must be greater than zero.' write ( im_chr , '(i0)' ) this_image () if ( present ( filename )) then this % filename_image = trim ( filename // '_im' // trim ( im_chr ) // '.data' ) this % filename = trim ( filename // '_co' // '.data' ) else this % filename_image = trim ( 'benchmark' // '_im' // trim ( im_chr ) // '.data' ) this % filename = trim ( 'benchmark' // '_co' // '.data' ) end if if ( present ( nloops )) then if ( nloops <= 0 ) error stop 'nloops must be greater than zero.' this % nloops = nloops else this % nloops = 10 end if allocate ( this % marks_co ( nmarks )[ * ]) allocate ( this % marks ( nmarks )) inquire ( file = this % filename_image , iostat = iostat ) if ( iostat /= 0 ) then error stop 'file ' // trim ( this % filename_image ) // ' cannot be accessed.' end if open ( newunit = nunit , file = this % filename_image ) write ( nunit , '(a)' ) '-----------------------------------------------------' write ( nunit , '(a)' ) 'ForBenchmark - https://github.com/gha3mi/forbenchmark' write ( nunit , '(a)' ) '-----------------------------------------------------' write ( nunit , '(a)' ) '' if ( present ( title )) then write ( nunit , '(a)' ) trim ( title ) else write ( nunit , '(a)' ) 'ForBenchmark' end if write ( nunit , '(a)' ) current_date_and_time () write ( nunit , '(a)' ) '' write ( nunit , '(a,a)' ) 'compiler_version: ' , compiler_version () write ( nunit , '(a,a)' ) 'compiler_options: ' , compiler_options () write ( nunit , '(a,g0,a,g0)' ) 'image: ' , this_image (), ' of ' , num_images () write ( nunit , '(a)' ) '' write ( nunit , '(a)' ) & & '       METHOD        |& &     TIME(image)      |& &    GFLOPS(image)     |& &  NLOOPS  |& &   ARGI  ' close ( nunit ) if ( this_image () == 1 ) then inquire ( file = this % filename , iostat = iostat ) if ( iostat /= 0 ) then error stop 'file ' // trim ( this % filename ) // ' cannot be accessed.' end if open ( newunit = nunit , file = this % filename ) write ( nunit , '(a)' ) '-----------------------------------------------------' write ( nunit , '(a)' ) 'ForBenchmark - https://github.com/gha3mi/forbenchmark' write ( nunit , '(a)' ) '-----------------------------------------------------' write ( nunit , '(a)' ) '' if ( present ( title )) then write ( nunit , '(a)' ) trim ( title ) else write ( nunit , '(a)' ) 'ForBenchmark' end if write ( nunit , '(a)' ) current_date_and_time () write ( nunit , '(a)' ) '' write ( nunit , '(a,a)' ) 'compiler_version: ' , compiler_version () write ( nunit , '(a,a)' ) 'compiler_options: ' , compiler_options () write ( nunit , '(a,g0)' ) 'num_image: ' , num_images () write ( nunit , '(a)' ) '' write ( nunit , '(a)' ) & & '       METHOD        |& & SPEEDUP(max) |& &      TIME(max)       |& &      TIME(min)       |& &      TIME(avg)       |& &     GFLOPS(tot)      |& &  NLOOPS  |& &   ARGI  ' close ( nunit ) end if end subroutine init","tags":"","loc":"proc/init~2.html"},{"title":"start_benchmark – ForBenchmark","text":"private impure subroutine start_benchmark(this, imark, method, description, argi, argr) Uses face proc~~start_benchmark~2~~UsesGraph proc~start_benchmark~2 forbenchmark_coarray::benchmark%start_benchmark face face proc~start_benchmark~2->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type Bound benchmark Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this integer, intent(in) :: imark character(len=*), intent(in) :: method character(len=*), intent(in), optional :: description integer, intent(in), optional, dimension(:) :: argi real(kind=rk), intent(in), optional, dimension(:) :: argr Calls proc~~start_benchmark~2~~CallsGraph proc~start_benchmark~2 forbenchmark_coarray::benchmark%start_benchmark colorize colorize proc~start_benchmark~2->colorize timer_start timer_start proc~start_benchmark~2->timer_start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine start_benchmark ( this , imark , method , description , argi , argr ) !! author: Seyed Ali Ghasemi use face class ( benchmark ), intent ( inout ) :: this integer , intent ( in ) :: imark character ( * ), intent ( in ) :: method integer , dimension (:), intent ( in ), optional :: argi real ( rk ), dimension (:), intent ( in ), optional :: argr character ( * ), intent ( in ), optional :: description if ( imark <= 0 . or . imark > size ( this % marks )) error stop 'imark is out of range.' this % marks ( imark )% description = description this % marks ( imark )% method = method if ( present ( argi )) then this % argi = argi else if (. not . allocated ( this % argi )) allocate ( this % argi ( 0 )) endif if ( present ( argr )) then this % argr = argr else if (. not . allocated ( this % argr )) allocate ( this % argr ( 0 )) endif sync all if ( present ( description ) . and . present ( argi ) . and . this_image () == 1 ) then print '(a,a,\" \",a,*(g0,1x))' ,& colorize ( 'Meth.: ' // this % marks ( imark )% method , color_fg = 'green' , style = 'bold_on' ),& colorize ( '; Des.: ' // this % marks ( imark )% description , color_fg = 'green_intense' ),& '; Argi.:' ,& this % argi elseif (. not . present ( description ) . and . present ( argi ) . and . this_image () == 1 ) then print '(a,\" \",a,*(g0,1x))' ,& colorize ( 'Meth.: ' // this % marks ( imark )% method , color_fg = 'green' , style = 'bold_on' ),& '; Argi.:' ,& this % argi elseif ( present ( description ) . and . . not . present ( argi ) . and . this_image () == 1 ) then print '(a,a)' ,& colorize ( 'Meth.: ' // this % marks ( imark )% method , color_fg = 'green' , style = 'bold_on' ),& colorize ( '; Des.: ' // this % marks ( imark )% description , color_fg = 'green_intense' ) elseif (. not . present ( description ) . and . . not . present ( argi ) . and . this_image () == 1 ) then print '(a)' , colorize ( 'Meth.: ' // this % marks ( imark )% method , color_fg = 'green' , style = 'bold_on' ) end if call this % marks_co ( imark )% time % timer_start () end subroutine start_benchmark","tags":"","loc":"proc/start_benchmark~2.html"},{"title":"stop_benchmark – ForBenchmark","text":"private impure subroutine stop_benchmark(this, imark, flops) Uses face proc~~stop_benchmark~2~~UsesGraph proc~stop_benchmark~2 forbenchmark_coarray::benchmark%stop_benchmark face face proc~stop_benchmark~2->face Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type Bound benchmark Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this integer, intent(in) :: imark procedure(Fun), optional :: flops Calls proc~~stop_benchmark~2~~CallsGraph proc~stop_benchmark~2 forbenchmark_coarray::benchmark%stop_benchmark colorize colorize proc~stop_benchmark~2->colorize proc~write_benchmark~2 forbenchmark_coarray::benchmark%write_benchmark proc~stop_benchmark~2->proc~write_benchmark~2 timer_stop timer_stop proc~stop_benchmark~2->timer_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine stop_benchmark ( this , imark , flops ) !! author: Seyed Ali Ghasemi use face interface impure function Fun ( argi , argr ) import rk integer , dimension (:), intent ( in ), optional :: argi real ( rk ), dimension (:), intent ( in ), optional :: argr real ( rk ) :: Fun end function Fun end interface procedure ( Fun ), optional :: flops class ( benchmark ), intent ( inout ) :: this integer , intent ( in ) :: imark real ( rk ) :: elapsed_time_average , elapsed_time_min , elapsed_time_max real ( rk ) :: flops_total integer :: i real ( rk ), dimension (:), allocatable :: elapsed_times if ( imark <= 0 . or . imark > size ( this % marks )) error stop 'imark is out of range.' call this % marks_co ( imark )% time % timer_stop ( message = ' Elapsed time :' , nloops = this % nloops ) if ( present ( flops )) then this % marks_co ( imark )% flops = flops ( this % argi , this % argr ) / this % marks_co ( imark )% time % elapsed_time print '(a,f7.3,a)' , ' Performance  :' , this % marks_co ( imark )% flops , ' [GFLOPS/image]' else this % marks_co ( imark )% flops = 0.0_rk end if sync all if ( this_image () == 1 ) then allocate ( elapsed_times ( num_images ())) do i = 1 , num_images () elapsed_times ( i ) = this % marks_co ( imark )[ i ]% time % elapsed_time end do elapsed_time_max = maxval ( elapsed_times ) elapsed_time_min = minval ( elapsed_times ) elapsed_time_average = sum ( elapsed_times ) / num_images () if ( present ( flops )) flops_total = 0.0_rk do i = 1 , num_images () if ( present ( flops )) flops_total = flops_total + this % marks_co ( imark )[ i ]% flops end do end if call co_broadcast ( elapsed_time_average , 1 ) call co_broadcast ( elapsed_time_min , 1 ) call co_broadcast ( elapsed_time_max , 1 ) if ( present ( flops )) call co_broadcast ( flops_total , 1 ) this % marks ( imark )% elapsed_time_average = elapsed_time_average this % marks ( imark )% elapsed_time_min = elapsed_time_min this % marks ( imark )% elapsed_time_max = elapsed_time_max this % marks ( imark )% speedup_max_total = this % marks ( imark )% elapsed_time_max / this % marks ( 1 )% elapsed_time_max if ( this_image () == 1 ) then print '(a,f7.3,a)' , colorize ( ' Elapsed time (max)     :' , color_fg = 'blue' ),& this % marks ( imark )% elapsed_time_max , ' [s]' print '(a,f7.3,a)' , colorize ( ' Elapsed time (min)     :' , color_fg = 'blue' ),& this % marks ( imark )% elapsed_time_min , ' [s]' print '(a,f7.3,a)' , colorize ( ' Elapsed time (average) :' , color_fg = 'blue' ),& this % marks ( imark )% elapsed_time_average , ' [s]' print '(a,f7.3,a)' , colorize ( ' Speedup (max)          :' , color_fg = 'blue' ),& this % marks ( imark )% speedup_max_total , ' [-]' if ( present ( flops )) print '(a,f7.3,a)' , colorize ( ' Performance  (total)   :' , color_fg = 'cyan' ),& flops_total , ' [GFLOPS]' print '(a)' , '' end if if ( present ( flops )) then this % marks ( imark )% flops_total = flops_total else this % marks ( imark )% flops_total = 0.0_rk end if call this % write_benchmark ( imark ) end subroutine stop_benchmark","tags":"","loc":"proc/stop_benchmark~2.html"},{"title":"write_benchmark – ForBenchmark","text":"private impure subroutine write_benchmark(this, imark) Type Bound benchmark Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this integer, intent(in) :: imark Called by proc~~write_benchmark~2~~CalledByGraph proc~write_benchmark~2 forbenchmark_coarray::benchmark%write_benchmark proc~stop_benchmark~2 forbenchmark_coarray::benchmark%stop_benchmark proc~stop_benchmark~2->proc~write_benchmark~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine write_benchmark ( this , imark ) !! author: Seyed Ali Ghasemi class ( benchmark ), intent ( inout ) :: this integer , intent ( in ) :: imark integer :: nunit character ( len = 53 ) :: fmt1 character ( len = 82 ) :: fmt2 integer :: lm logical :: exist integer :: iostat if ( imark <= 0 . or . imark > size ( this % marks )) error stop 'imark is out of range.' lm = 20 - len_trim ( this % marks ( imark )% method ) write ( fmt1 , '(a,g0,a)' )& '(a,' , lm , 'x,3x,E20.14,3x,E20.14,3x,g8.0,3x,*(g8.0,3x))' inquire ( file = this % filename_image , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename_image ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename_image , access = 'append' ) write ( nunit , fmt1 ) & this % marks ( imark )% method ,& this % marks_co ( imark )% time % elapsed_time ,& this % marks_co ( imark )% flops ,& this % nloops ,& this % argi close ( nunit ) if ( this_image () == 1 ) then write ( fmt2 , '(a,g0,a)' )& '(a,' , lm , 'x,3x,F12.6,3x,E20.14,3x,E20.14,3x,E20.14,3x,E20.14,3x,g8.0,3x,*(g8.0,3x))' inquire ( file = this % filename , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename , access = 'append' ) write ( nunit , fmt2 ) & this % marks ( imark )% method ,& this % marks ( imark )% speedup_max_total ,& this % marks ( imark )% elapsed_time_max ,& this % marks ( imark )% elapsed_time_min ,& this % marks ( imark )% elapsed_time_average ,& this % marks ( imark )% flops_total ,& this % nloops ,& this % argi close ( nunit ) end if end subroutine write_benchmark","tags":"","loc":"proc/write_benchmark~2.html"},{"title":"finalize_mark – ForBenchmark","text":"private pure elemental subroutine finalize_mark(this) Type Bound mark Arguments Type Intent Optional Attributes Name class( mark ), intent(inout) :: this Called by proc~~finalize_mark~2~~CalledByGraph proc~finalize_mark~2 forbenchmark_coarray::mark%finalize_mark proc~finalize~2 forbenchmark_coarray::benchmark%finalize proc~finalize~2->proc~finalize_mark~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure elemental subroutine finalize_mark ( this ) !! author: Seyed Ali Ghasemi class ( mark ), intent ( inout ) :: this if ( allocated ( this % method )) deallocate ( this % method ) if ( allocated ( this % description )) deallocate ( this % description ) end subroutine finalize_mark","tags":"","loc":"proc/finalize_mark~2.html"},{"title":"finalize – ForBenchmark","text":"private impure elemental subroutine finalize(this) Type Bound benchmark Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Calls proc~~finalize~2~~CallsGraph proc~finalize~2 forbenchmark_coarray::benchmark%finalize proc~finalize_mark~2 forbenchmark_coarray::mark%finalize_mark proc~finalize~2->proc~finalize_mark~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental impure subroutine finalize ( this ) !! author: Seyed Ali Ghasemi class ( benchmark ), intent ( inout ) :: this integer :: nunit logical :: exist integer :: iostat inquire ( file = this % filename_image , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename_image ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename_image , access = 'append' ) write ( nunit , '(a)' ) 'end of benchmark' close ( nunit ) if ( this_image () == 1 ) then inquire ( file = this % filename , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename , access = 'append' ) write ( nunit , '(a)' ) 'end of benchmark' close ( nunit ) end if if ( allocated ( this % marks_co )) deallocate ( this % marks_co ) call this % marks % finalize_mark () if ( allocated ( this % marks )) deallocate ( this % marks ) if ( allocated ( this % filename_image )) deallocate ( this % filename_image ) if ( allocated ( this % argi )) deallocate ( this % argi ) if ( allocated ( this % argr )) deallocate ( this % argr ) if ( this_image () == 1 ) print '(a)' , 'end of benchmark' end subroutine finalize","tags":"","loc":"proc/finalize~2.html"},{"title":"forbenchmark_default – ForBenchmark","text":"Uses kinds fortime module~~forbenchmark_default~~UsesGraph module~forbenchmark_default forbenchmark_default fortime fortime module~forbenchmark_default->fortime kinds kinds module~forbenchmark_default->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forbenchmark_default~~UsedByGraph module~forbenchmark_default forbenchmark_default module~forbenchmark forbenchmark module~forbenchmark->module~forbenchmark_default program~demo demo program~demo->module~forbenchmark Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, private :: mark Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: method character(len=:), public, allocatable :: description type(timer), public :: time real(kind=rk), public :: speedup real(kind=rk), public :: flops Type-Bound Procedures procedure, private :: finalize_mark type, public :: benchmark Components Type Visibility Attributes Name Initial type( mark ), public, dimension(:), allocatable :: marks character(len=:), public, allocatable :: filename integer, public :: nloops integer, public, dimension(:), allocatable :: argi real(kind=rk), public, dimension(:), allocatable :: argr Type-Bound Procedures procedure, public :: init procedure, public :: start_benchmark procedure, public :: stop_benchmark procedure, private :: write_benchmark procedure, public :: finalize Functions private impure function current_date_and_time () result(datetime) Author Seyed Ali Ghasemi Arguments None Return Value character(len=21) Subroutines private impure elemental subroutine init (this, nmarks, title, filename, nloops) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this integer, intent(in) :: nmarks character(len=*), intent(in), optional :: title character(len=*), intent(in), optional :: filename integer, intent(in), optional :: nloops private impure subroutine start_benchmark (this, imark, method, description, argi, argr) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this integer, intent(in) :: imark character(len=*), intent(in) :: method character(len=*), intent(in), optional :: description integer, intent(in), optional, dimension(:) :: argi real(kind=rk), intent(in), optional, dimension(:) :: argr private impure subroutine stop_benchmark (this, imark, flops) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this integer, intent(in) :: imark procedure(Fun), optional :: flops private impure subroutine write_benchmark (this, imark) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this integer, intent(in) :: imark private pure elemental subroutine finalize_mark (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( mark ), intent(inout) :: this private impure elemental subroutine finalize (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this","tags":"","loc":"module/forbenchmark_default.html"},{"title":"forbenchmark_coarray – ForBenchmark","text":"Uses kinds fortime module~~forbenchmark_coarray~~UsesGraph module~forbenchmark_coarray forbenchmark_coarray fortime fortime module~forbenchmark_coarray->fortime kinds kinds module~forbenchmark_coarray->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forbenchmark_coarray~~UsedByGraph module~forbenchmark_coarray forbenchmark_coarray module~forbenchmark forbenchmark module~forbenchmark->module~forbenchmark_coarray program~demo demo program~demo->module~forbenchmark Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, private :: mark_co Components Type Visibility Attributes Name Initial type(timer), public :: time real(kind=rk), public :: flops type, private :: mark Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: method character(len=:), public, allocatable :: description real(kind=rk), public :: elapsed_time_min real(kind=rk), public :: elapsed_time_average real(kind=rk), public :: elapsed_time_max real(kind=rk), public :: flops_total real(kind=rk), public :: speedup_max_total Type-Bound Procedures procedure, private :: finalize_mark type, public :: benchmark Components Type Visibility Attributes Name Initial type( mark_co ), public, dimension(:), allocatable :: marks_co [:] type( mark ), public, dimension(:), allocatable :: marks character(len=:), public, allocatable :: filename character(len=:), public, allocatable :: filename_image integer, public :: nloops integer, public, dimension(:), allocatable :: argi real(kind=rk), public, dimension(:), allocatable :: argr Type-Bound Procedures procedure, public :: init procedure, public :: start_benchmark procedure, public :: stop_benchmark procedure, private :: write_benchmark procedure, public :: finalize Functions private impure function current_date_and_time () result(datetime) Author Seyed Ali Ghasemi Arguments None Return Value character(len=21) Subroutines private impure elemental subroutine init (this, nmarks, title, filename, nloops) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this integer, intent(in) :: nmarks character(len=*), intent(in), optional :: title character(len=*), intent(in), optional :: filename integer, intent(in), optional :: nloops private impure subroutine start_benchmark (this, imark, method, description, argi, argr) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this integer, intent(in) :: imark character(len=*), intent(in) :: method character(len=*), intent(in), optional :: description integer, intent(in), optional, dimension(:) :: argi real(kind=rk), intent(in), optional, dimension(:) :: argr private impure subroutine stop_benchmark (this, imark, flops) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this integer, intent(in) :: imark procedure(Fun), optional :: flops private impure subroutine write_benchmark (this, imark) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this integer, intent(in) :: imark private pure elemental subroutine finalize_mark (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( mark ), intent(inout) :: this private impure elemental subroutine finalize (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this","tags":"","loc":"module/forbenchmark_coarray.html"},{"title":"forbenchmark – ForBenchmark","text":"Uses forbenchmark_coarray forbenchmark_default module~~forbenchmark~~UsesGraph module~forbenchmark forbenchmark module~forbenchmark_coarray forbenchmark_coarray module~forbenchmark->module~forbenchmark_coarray module~forbenchmark_default forbenchmark_default module~forbenchmark->module~forbenchmark_default fortime fortime module~forbenchmark_coarray->fortime kinds kinds module~forbenchmark_coarray->kinds module~forbenchmark_default->fortime module~forbenchmark_default->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forbenchmark~~UsedByGraph module~forbenchmark forbenchmark program~demo demo program~demo->module~forbenchmark Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"module/forbenchmark.html"},{"title":"demo – ForBenchmark","text":"Uses kinds forbenchmark program~~demo~~UsesGraph program~demo demo kinds kinds program~demo->kinds module~forbenchmark forbenchmark program~demo->module~forbenchmark module~forbenchmark_coarray forbenchmark_coarray module~forbenchmark->module~forbenchmark_coarray module~forbenchmark_default forbenchmark_default module~forbenchmark->module~forbenchmark_default module~forbenchmark_coarray->kinds fortime fortime module~forbenchmark_coarray->fortime module~forbenchmark_default->kinds module~forbenchmark_default->fortime Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~demo~~CallsGraph program~demo demo proc~finalize forbenchmark_default::benchmark%finalize program~demo->proc~finalize proc~init forbenchmark_default::benchmark%init program~demo->proc~init proc~start_benchmark forbenchmark_default::benchmark%start_benchmark program~demo->proc~start_benchmark proc~stop_benchmark forbenchmark_default::benchmark%stop_benchmark program~demo->proc~stop_benchmark proc~finalize_mark forbenchmark_default::mark%finalize_mark proc~finalize->proc~finalize_mark proc~current_date_and_time forbenchmark_default::current_date_and_time proc~init->proc~current_date_and_time colorize colorize proc~start_benchmark->colorize timer_start timer_start proc~start_benchmark->timer_start proc~write_benchmark forbenchmark_default::benchmark%write_benchmark proc~stop_benchmark->proc~write_benchmark timer_stop timer_stop proc~stop_benchmark->timer_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( benchmark ) :: bench real(kind=rk), dimension(:,:), allocatable :: A real(kind=rk), dimension(:,:), allocatable :: B real(kind=rk), dimension(:,:), allocatable :: C integer :: nl integer :: p integer :: i integer :: j integer :: k Functions function cmp_gflops (argi, argr) result(gflops) Arguments Type Intent Optional Attributes Name integer, intent(in), optional, dimension(:) :: argi real(kind=rk), intent(in), optional, dimension(:) :: argr Return Value real(kind=rk) Source Code program demo use kinds , only : rk ! use -DREAL32 or -DREAL64 to switch between real32 and real64, default is real64 use forbenchmark , only : benchmark ! forbenchmark module implicit none ! benchmark object type ( benchmark ) :: bench ! define your variables here real ( rk ), dimension (:,:), allocatable :: A , B , C integer :: nl , p , i , j , k ! initialize the benchmark ! nmarks: number of methods to benchmark ! title: optional ! filename: optional. make sure directory exists ! nloops: optional. number of loops for each benchmark. default is 10. call bench % init ( nmarks = 2 , title = 'Demo Benchmark' , filename = 'results/demo' , nloops = 2 ) ! start the benchmark do p = 100 , 400 , 100 ! loop over problem size !=============================================================================== ! allocate and initialize your variables here if ( allocated ( A )) deallocate ( A ) if ( allocated ( B )) deallocate ( B ) if ( allocated ( C )) deallocate ( C ) allocate ( A ( p , p )) allocate ( B ( p , p )) allocate ( C ( p , p ), source = 0.0_rk ) call random_number ( A ) call random_number ( B ) !=============================================================================== !=============================================================================== ! start benchmark for method 1 ! imark is an integer to identify the method, 1 is for reference method ! method is a string to identify the method ! description is optional ! argi is an optional integer array of arguments to write in the output file and to compute gflops ! the first element in argi is used for x-axis in the plot ! argr is an optional real array of arguments to compute gflops ! loop over nloops call bench % start_benchmark ( imark = 1 , method = 'm1' , description = 'intrinsic, C = matmul(A,B)' , argi = [ p , p , p ]) ! loop over nloops do nl = 1 , bench % nloops ! call your function or subroutine or ... ! here is used intrinsic matmul C = matmul ( A , B ) end do ! stop benchmark for method 1 ! imark is the same as above ! flops is an optional function to compute flops call bench % stop_benchmark ( imark = 1 , flops = cmp_gflops ) !=============================================================================== !=============================================================================== ! start benchmark for method 2, same as above. call bench % start_benchmark ( 2 , 'm2' , 'my_matmul, C = matmul(A,B)' , [ p , p , p ]) do nl = 1 , bench % nloops ! call your function or subroutine or ... ! here is used another matmul C = 0.0_rk do i = 1 , p do j = 1 , p do k = 1 , p C ( i , j ) = C ( i , j ) + A ( i , k ) * B ( k , j ) end do end do end do end do call bench % stop_benchmark ( 2 , cmp_gflops ) !=============================================================================== ! you can add more methods ... end do ! end loop over p ! finalize the benchmark call bench % finalize () ! you can use a python script to plot the results as follows: ! python results/plot.py demo.data ! for coarray benchmarks, utilize: ! python results/plot_co.py demo_co.data ! python results/plot_im.py demo_im1.data ! python results/plot_im.py demo_im2.data ! ... contains !=============================================================================== ! define an optional function to compute gflops function cmp_gflops ( argi , argr ) result ( gflops ) integer , dimension (:), intent ( in ), optional :: argi real ( rk ), dimension (:), intent ( in ), optional :: argr real ( rk ) :: gflops gflops = real ( argi ( 1 ), rk ) * real ( argi ( 2 ), rk ) * real ( argi ( 3 ), rk ) * 1.0e-9_rk end function cmp_gflops !=============================================================================== end program demo","tags":"","loc":"program/demo.html"},{"title":"demo.f90 – ForBenchmark","text":"This file depends on sourcefile~~demo.f90~~EfferentGraph sourcefile~demo.f90 demo.f90 sourcefile~forbenchmark.f90 forbenchmark.f90 sourcefile~demo.f90->sourcefile~forbenchmark.f90 sourcefile~forbenchmark_coarray.f90 forbenchmark_coarray.f90 sourcefile~forbenchmark.f90->sourcefile~forbenchmark_coarray.f90 sourcefile~forbenchmark_default.f90 forbenchmark_default.f90 sourcefile~forbenchmark.f90->sourcefile~forbenchmark_default.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! this is a demo program for forbenchmark. ! can be used for serial or coarray benchmarks. ! use -DUSE_COARRAY to compile for coarray benchmarks. program demo use kinds , only : rk ! use -DREAL32 or -DREAL64 to switch between real32 and real64, default is real64 use forbenchmark , only : benchmark ! forbenchmark module implicit none ! benchmark object type ( benchmark ) :: bench ! define your variables here real ( rk ), dimension (:,:), allocatable :: A , B , C integer :: nl , p , i , j , k ! initialize the benchmark ! nmarks: number of methods to benchmark ! title: optional ! filename: optional. make sure directory exists ! nloops: optional. number of loops for each benchmark. default is 10. call bench % init ( nmarks = 2 , title = 'Demo Benchmark' , filename = 'results/demo' , nloops = 2 ) ! start the benchmark do p = 100 , 400 , 100 ! loop over problem size !=============================================================================== ! allocate and initialize your variables here if ( allocated ( A )) deallocate ( A ) if ( allocated ( B )) deallocate ( B ) if ( allocated ( C )) deallocate ( C ) allocate ( A ( p , p )) allocate ( B ( p , p )) allocate ( C ( p , p ), source = 0.0_rk ) call random_number ( A ) call random_number ( B ) !=============================================================================== !=============================================================================== ! start benchmark for method 1 ! imark is an integer to identify the method, 1 is for reference method ! method is a string to identify the method ! description is optional ! argi is an optional integer array of arguments to write in the output file and to compute gflops ! the first element in argi is used for x-axis in the plot ! argr is an optional real array of arguments to compute gflops ! loop over nloops call bench % start_benchmark ( imark = 1 , method = 'm1' , description = 'intrinsic, C = matmul(A,B)' , argi = [ p , p , p ]) ! loop over nloops do nl = 1 , bench % nloops ! call your function or subroutine or ... ! here is used intrinsic matmul C = matmul ( A , B ) end do ! stop benchmark for method 1 ! imark is the same as above ! flops is an optional function to compute flops call bench % stop_benchmark ( imark = 1 , flops = cmp_gflops ) !=============================================================================== !=============================================================================== ! start benchmark for method 2, same as above. call bench % start_benchmark ( 2 , 'm2' , 'my_matmul, C = matmul(A,B)' , [ p , p , p ]) do nl = 1 , bench % nloops ! call your function or subroutine or ... ! here is used another matmul C = 0.0_rk do i = 1 , p do j = 1 , p do k = 1 , p C ( i , j ) = C ( i , j ) + A ( i , k ) * B ( k , j ) end do end do end do end do call bench % stop_benchmark ( 2 , cmp_gflops ) !=============================================================================== ! you can add more methods ... end do ! end loop over p ! finalize the benchmark call bench % finalize () ! you can use a python script to plot the results as follows: ! python results/plot.py demo.data ! for coarray benchmarks, utilize: ! python results/plot_co.py demo_co.data ! python results/plot_im.py demo_im1.data ! python results/plot_im.py demo_im2.data ! ... contains !=============================================================================== ! define an optional function to compute gflops function cmp_gflops ( argi , argr ) result ( gflops ) integer , dimension (:), intent ( in ), optional :: argi real ( rk ), dimension (:), intent ( in ), optional :: argr real ( rk ) :: gflops gflops = real ( argi ( 1 ), rk ) * real ( argi ( 2 ), rk ) * real ( argi ( 3 ), rk ) * 1.0e-9_rk end function cmp_gflops !=============================================================================== end program demo","tags":"","loc":"sourcefile/demo.f90.html"},{"title":"forbenchmark_default.f90 – ForBenchmark","text":"Files dependent on this one sourcefile~~forbenchmark_default.f90~~AfferentGraph sourcefile~forbenchmark_default.f90 forbenchmark_default.f90 sourcefile~forbenchmark.f90 forbenchmark.f90 sourcefile~forbenchmark.f90->sourcefile~forbenchmark_default.f90 sourcefile~demo.f90 demo.f90 sourcefile~demo.f90->sourcefile~forbenchmark.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module forbenchmark_default !! author: Seyed Ali Ghasemi use kinds use fortime , only : timer implicit none private public benchmark !=============================================================================== type :: mark !! author: Seyed Ali Ghasemi character (:), allocatable :: method character (:), allocatable :: description type ( timer ) :: time real ( rk ) :: speedup real ( rk ) :: flops contains procedure , private :: finalize_mark end type mark !=============================================================================== !=============================================================================== type :: benchmark !! author: Seyed Ali Ghasemi type ( mark ), dimension (:), allocatable :: marks character (:), allocatable :: filename integer :: nloops integer , dimension (:), allocatable :: argi real ( rk ), dimension (:), allocatable :: argr contains procedure :: init procedure :: start_benchmark procedure :: stop_benchmark procedure , private :: write_benchmark procedure :: finalize end type benchmark !=============================================================================== contains !=============================================================================== elemental impure subroutine init ( this , nmarks , title , filename , nloops ) !! author: Seyed Ali Ghasemi use , intrinsic :: iso_fortran_env , only : compiler_version , compiler_options class ( benchmark ), intent ( inout ) :: this integer , intent ( in ) :: nmarks character ( * ), intent ( in ), optional :: title character ( * ), intent ( in ), optional :: filename integer , intent ( in ), optional :: nloops integer :: nunit integer :: iostat if ( nmarks <= 0 ) error stop 'nmarks must be greater than zero.' allocate ( this % marks ( nmarks )) if ( present ( filename )) then this % filename = trim ( filename // '.data' ) else this % filename = 'benchmark.data' endif if ( present ( nloops )) then if ( nloops <= 0 ) error stop 'nloops must be greater than zero.' this % nloops = nloops else this % nloops = 10 end if inquire ( file = this % filename , iostat = iostat ) if ( iostat /= 0 ) then error stop 'file ' // trim ( this % filename ) // ' cannot be accessed.' end if open ( newunit = nunit , file = this % filename ) write ( nunit , '(a)' ) '-----------------------------------------------------' write ( nunit , '(a)' ) 'ForBenchmark - https://github.com/gha3mi/forbenchmark' write ( nunit , '(a)' ) '-----------------------------------------------------' write ( nunit , '(a)' ) '' if ( present ( title )) then write ( nunit , '(a)' ) trim ( title ) else write ( nunit , '(a)' ) 'ForBenchmark' endif write ( nunit , '(a)' ) current_date_and_time () write ( nunit , '(a)' ) '' write ( nunit , '(a,a)' ) 'compiler_version: ' , compiler_version () write ( nunit , '(a,a)' ) 'compiler_options: ' , compiler_options () write ( nunit , '(a)' ) '' write ( nunit , '(a)' ) '' write ( nunit , '(a)' ) & & '       METHOD        |& &   SPEEDUP    |& &         TIME         |& &        GFLOPS        |& &  NLOOPS  |& &   ARGI  ' close ( nunit ) end subroutine init !=============================================================================== !=============================================================================== impure subroutine start_benchmark ( this , imark , method , description , argi , argr ) !! author: Seyed Ali Ghasemi use face class ( benchmark ), intent ( inout ) :: this integer , intent ( in ) :: imark character ( * ), intent ( in ) :: method integer , dimension (:), intent ( in ), optional :: argi real ( rk ), dimension (:), intent ( in ), optional :: argr character ( * ), intent ( in ), optional :: description if ( imark <= 0 . or . imark > size ( this % marks )) error stop 'imark is out of range.' this % marks ( imark )% description = description this % marks ( imark )% method = method if ( present ( argi )) then this % argi = argi else if (. not . allocated ( this % argi )) allocate ( this % argi ( 0 )) endif if ( present ( argr )) then this % argr = argr else if (. not . allocated ( this % argr )) allocate ( this % argr ( 0 )) endif if ( present ( description ) . and . present ( argi )) then print '(a,a,\" \",a,*(g0,1x))' ,& colorize ( 'Meth.: ' // this % marks ( imark )% method , color_fg = 'green' , style = 'bold_on' ),& colorize ( '; Des.: ' // this % marks ( imark )% description , color_fg = 'green_intense' ),& '; Argi.:' ,& this % argi elseif ( present ( description ) . and . . not . present ( argi )) then print '(a,a,\" \",a)' ,& colorize ( 'Meth.: ' // this % marks ( imark )% method , color_fg = 'green' , style = 'bold_on' ),& colorize ( '; Des.: ' // this % marks ( imark )% description , color_fg = 'green_intense' ) elseif (. not . present ( description ) . and . present ( argi )) then print '(a,a,*(g0,1x))' ,& colorize ( 'Meth.: ' // this % marks ( imark )% method , color_fg = 'green' , style = 'bold_on' ),& '; Argi.:' ,& this % argi else print '(a)' , colorize ( 'Meth.: ' // this % marks ( imark )% method , color_fg = 'green' , style = 'bold_on' ) end if call this % marks ( imark )% time % timer_start () end subroutine start_benchmark !=============================================================================== !=============================================================================== impure subroutine stop_benchmark ( this , imark , flops ) !! author: Seyed Ali Ghasemi interface impure function Fun ( argi , argr ) import rk integer , dimension (:), intent ( in ), optional :: argi real ( rk ), dimension (:), intent ( in ), optional :: argr real ( rk ) :: Fun end function Fun end interface procedure ( Fun ), optional :: flops class ( benchmark ), intent ( inout ) :: this integer , intent ( in ) :: imark if ( imark <= 0 . or . imark > size ( this % marks )) error stop 'imark is out of range.' call this % marks ( imark )% time % timer_stop ( message = ' Elapsed time :' , nloops = this % nloops ) this % marks ( imark )% speedup = this % marks ( imark )% time % elapsed_time / this % marks ( 1 )% time % elapsed_time if ( present ( flops )) then print '(a,f7.3,a)' , ' Speedup      :' , this % marks ( imark )% speedup , ' [-]' this % marks ( imark )% flops = flops ( this % argi , this % argr ) / this % marks ( imark )% time % elapsed_time print '(a,f7.3,a)' , ' Performance  :' , this % marks ( imark )% flops , ' [GFLOPS]' else this % marks ( imark )% flops = 0.0_rk endif print '(a)' , '' call this % write_benchmark ( imark ) end subroutine stop_benchmark !=============================================================================== !=============================================================================== impure subroutine write_benchmark ( this , imark ) !! author: Seyed Ali Ghasemi class ( benchmark ), intent ( inout ) :: this integer , intent ( in ) :: imark integer :: nunit character ( len = 65 ) :: fmt integer :: lm logical :: exist integer :: iostat if ( imark <= 0 . or . imark > size ( this % marks )) error stop 'imark is out of range.' inquire ( file = this % filename , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename , access = 'append' ) lm = 20 - len_trim ( this % marks ( imark )% method ) write ( fmt , '(a,g0,a)' ) '(a,' , lm , 'x,3x,F12.6,3x,E20.14,3x,E20.14,3x,g8.0,3x,*(g8.0,3x))' write ( nunit , fmt ) & this % marks ( imark )% method ,& this % marks ( imark )% speedup ,& this % marks ( imark )% time % elapsed_time ,& this % marks ( imark )% flops ,& this % nloops ,& this % argi close ( nunit ) end subroutine write_benchmark !=============================================================================== !=============================================================================== elemental pure subroutine finalize_mark ( this ) !! author: Seyed Ali Ghasemi class ( mark ), intent ( inout ) :: this if ( allocated ( this % method )) deallocate ( this % method ) if ( allocated ( this % description )) deallocate ( this % description ) end subroutine finalize_mark !=============================================================================== !=============================================================================== elemental impure subroutine finalize ( this ) !! author: Seyed Ali Ghasemi class ( benchmark ), intent ( inout ) :: this integer :: nunit logical :: exist integer :: iostat inquire ( file = this % filename , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename , access = 'append' ) write ( nunit , '(a)' ) 'end of benchmark' close ( nunit ) call this % marks (:)% finalize_mark () if ( allocated ( this % filename )) deallocate ( this % filename ) if ( allocated ( this % argi )) deallocate ( this % argi ) if ( allocated ( this % argr )) deallocate ( this % argr ) print '(a)' , 'end of benchmark' end subroutine finalize !=============================================================================== !=============================================================================== impure function current_date_and_time () result ( datetime ) !! author: Seyed Ali Ghasemi character ( 21 ) :: datetime character ( 10 ) :: date character ( 8 ) :: time integer :: values ( 8 ) character ( 4 ) :: year character ( 2 ) :: month , day , hour , minute , second call date_and_time ( values = values ) write ( year , '(i4)' ) values ( 1 ) write ( month , '(i2)' ) values ( 2 ) write ( day , '(i2)' ) values ( 3 ) write ( hour , '(i2)' ) values ( 5 ) write ( minute , '(i2)' ) values ( 6 ) write ( second , '(i2)' ) values ( 7 ) date = year // '.' // month // '.' // day time = hour // ':' // minute // ':' // second datetime = date // ' - ' // time end function current_date_and_time !=============================================================================== end module forbenchmark_default","tags":"","loc":"sourcefile/forbenchmark_default.f90.html"},{"title":"forbenchmark_coarray.f90 – ForBenchmark","text":"Files dependent on this one sourcefile~~forbenchmark_coarray.f90~~AfferentGraph sourcefile~forbenchmark_coarray.f90 forbenchmark_coarray.f90 sourcefile~forbenchmark.f90 forbenchmark.f90 sourcefile~forbenchmark.f90->sourcefile~forbenchmark_coarray.f90 sourcefile~demo.f90 demo.f90 sourcefile~demo.f90->sourcefile~forbenchmark.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module forbenchmark_coarray !! author: Seyed Ali Ghasemi #if defined(USE_COARRAY) use kinds use fortime , only : timer implicit none private public benchmark !=============================================================================== type :: mark_co !! author: Seyed Ali Ghasemi type ( timer ) :: time real ( rk ) :: flops end type mark_co !=============================================================================== !=============================================================================== type :: mark !! author: Seyed Ali Ghasemi character (:), allocatable :: method character (:), allocatable :: description real ( rk ) :: elapsed_time_min real ( rk ) :: elapsed_time_average real ( rk ) :: elapsed_time_max real ( rk ) :: flops_total real ( rk ) :: speedup_max_total contains procedure , private :: finalize_mark end type mark !=============================================================================== !=============================================================================== type :: benchmark !! author: Seyed Ali Ghasemi type ( mark_co ), dimension (:), allocatable :: marks_co [:] type ( mark ), dimension (:), allocatable :: marks character (:), allocatable :: filename character (:), allocatable :: filename_image integer :: nloops integer , dimension (:), allocatable :: argi real ( rk ), dimension (:), allocatable :: argr contains procedure :: init procedure :: start_benchmark procedure :: stop_benchmark procedure , private :: write_benchmark procedure :: finalize end type benchmark !=============================================================================== contains !=============================================================================== elemental impure subroutine init ( this , nmarks , title , filename , nloops ) !! author: Seyed Ali Ghasemi use , intrinsic :: iso_fortran_env , only : compiler_version , compiler_options class ( benchmark ), intent ( inout ) :: this integer , intent ( in ) :: nmarks character ( * ), intent ( in ), optional :: title character ( * ), intent ( in ), optional :: filename integer , intent ( in ), optional :: nloops integer :: nunit integer :: iostat character ( 10 ) :: im_chr if ( nmarks <= 0 ) error stop 'nmarks must be greater than zero.' write ( im_chr , '(i0)' ) this_image () if ( present ( filename )) then this % filename_image = trim ( filename // '_im' // trim ( im_chr ) // '.data' ) this % filename = trim ( filename // '_co' // '.data' ) else this % filename_image = trim ( 'benchmark' // '_im' // trim ( im_chr ) // '.data' ) this % filename = trim ( 'benchmark' // '_co' // '.data' ) end if if ( present ( nloops )) then if ( nloops <= 0 ) error stop 'nloops must be greater than zero.' this % nloops = nloops else this % nloops = 10 end if allocate ( this % marks_co ( nmarks )[ * ]) allocate ( this % marks ( nmarks )) inquire ( file = this % filename_image , iostat = iostat ) if ( iostat /= 0 ) then error stop 'file ' // trim ( this % filename_image ) // ' cannot be accessed.' end if open ( newunit = nunit , file = this % filename_image ) write ( nunit , '(a)' ) '-----------------------------------------------------' write ( nunit , '(a)' ) 'ForBenchmark - https://github.com/gha3mi/forbenchmark' write ( nunit , '(a)' ) '-----------------------------------------------------' write ( nunit , '(a)' ) '' if ( present ( title )) then write ( nunit , '(a)' ) trim ( title ) else write ( nunit , '(a)' ) 'ForBenchmark' end if write ( nunit , '(a)' ) current_date_and_time () write ( nunit , '(a)' ) '' write ( nunit , '(a,a)' ) 'compiler_version: ' , compiler_version () write ( nunit , '(a,a)' ) 'compiler_options: ' , compiler_options () write ( nunit , '(a,g0,a,g0)' ) 'image: ' , this_image (), ' of ' , num_images () write ( nunit , '(a)' ) '' write ( nunit , '(a)' ) & & '       METHOD        |& &     TIME(image)      |& &    GFLOPS(image)     |& &  NLOOPS  |& &   ARGI  ' close ( nunit ) if ( this_image () == 1 ) then inquire ( file = this % filename , iostat = iostat ) if ( iostat /= 0 ) then error stop 'file ' // trim ( this % filename ) // ' cannot be accessed.' end if open ( newunit = nunit , file = this % filename ) write ( nunit , '(a)' ) '-----------------------------------------------------' write ( nunit , '(a)' ) 'ForBenchmark - https://github.com/gha3mi/forbenchmark' write ( nunit , '(a)' ) '-----------------------------------------------------' write ( nunit , '(a)' ) '' if ( present ( title )) then write ( nunit , '(a)' ) trim ( title ) else write ( nunit , '(a)' ) 'ForBenchmark' end if write ( nunit , '(a)' ) current_date_and_time () write ( nunit , '(a)' ) '' write ( nunit , '(a,a)' ) 'compiler_version: ' , compiler_version () write ( nunit , '(a,a)' ) 'compiler_options: ' , compiler_options () write ( nunit , '(a,g0)' ) 'num_image: ' , num_images () write ( nunit , '(a)' ) '' write ( nunit , '(a)' ) & & '       METHOD        |& & SPEEDUP(max) |& &      TIME(max)       |& &      TIME(min)       |& &      TIME(avg)       |& &     GFLOPS(tot)      |& &  NLOOPS  |& &   ARGI  ' close ( nunit ) end if end subroutine init !=============================================================================== !=============================================================================== impure subroutine start_benchmark ( this , imark , method , description , argi , argr ) !! author: Seyed Ali Ghasemi use face class ( benchmark ), intent ( inout ) :: this integer , intent ( in ) :: imark character ( * ), intent ( in ) :: method integer , dimension (:), intent ( in ), optional :: argi real ( rk ), dimension (:), intent ( in ), optional :: argr character ( * ), intent ( in ), optional :: description if ( imark <= 0 . or . imark > size ( this % marks )) error stop 'imark is out of range.' this % marks ( imark )% description = description this % marks ( imark )% method = method if ( present ( argi )) then this % argi = argi else if (. not . allocated ( this % argi )) allocate ( this % argi ( 0 )) endif if ( present ( argr )) then this % argr = argr else if (. not . allocated ( this % argr )) allocate ( this % argr ( 0 )) endif sync all if ( present ( description ) . and . present ( argi ) . and . this_image () == 1 ) then print '(a,a,\" \",a,*(g0,1x))' ,& colorize ( 'Meth.: ' // this % marks ( imark )% method , color_fg = 'green' , style = 'bold_on' ),& colorize ( '; Des.: ' // this % marks ( imark )% description , color_fg = 'green_intense' ),& '; Argi.:' ,& this % argi elseif (. not . present ( description ) . and . present ( argi ) . and . this_image () == 1 ) then print '(a,\" \",a,*(g0,1x))' ,& colorize ( 'Meth.: ' // this % marks ( imark )% method , color_fg = 'green' , style = 'bold_on' ),& '; Argi.:' ,& this % argi elseif ( present ( description ) . and . . not . present ( argi ) . and . this_image () == 1 ) then print '(a,a)' ,& colorize ( 'Meth.: ' // this % marks ( imark )% method , color_fg = 'green' , style = 'bold_on' ),& colorize ( '; Des.: ' // this % marks ( imark )% description , color_fg = 'green_intense' ) elseif (. not . present ( description ) . and . . not . present ( argi ) . and . this_image () == 1 ) then print '(a)' , colorize ( 'Meth.: ' // this % marks ( imark )% method , color_fg = 'green' , style = 'bold_on' ) end if call this % marks_co ( imark )% time % timer_start () end subroutine start_benchmark !=============================================================================== !=============================================================================== impure subroutine stop_benchmark ( this , imark , flops ) !! author: Seyed Ali Ghasemi use face interface impure function Fun ( argi , argr ) import rk integer , dimension (:), intent ( in ), optional :: argi real ( rk ), dimension (:), intent ( in ), optional :: argr real ( rk ) :: Fun end function Fun end interface procedure ( Fun ), optional :: flops class ( benchmark ), intent ( inout ) :: this integer , intent ( in ) :: imark real ( rk ) :: elapsed_time_average , elapsed_time_min , elapsed_time_max real ( rk ) :: flops_total integer :: i real ( rk ), dimension (:), allocatable :: elapsed_times if ( imark <= 0 . or . imark > size ( this % marks )) error stop 'imark is out of range.' call this % marks_co ( imark )% time % timer_stop ( message = ' Elapsed time :' , nloops = this % nloops ) if ( present ( flops )) then this % marks_co ( imark )% flops = flops ( this % argi , this % argr ) / this % marks_co ( imark )% time % elapsed_time print '(a,f7.3,a)' , ' Performance  :' , this % marks_co ( imark )% flops , ' [GFLOPS/image]' else this % marks_co ( imark )% flops = 0.0_rk end if sync all if ( this_image () == 1 ) then allocate ( elapsed_times ( num_images ())) do i = 1 , num_images () elapsed_times ( i ) = this % marks_co ( imark )[ i ]% time % elapsed_time end do elapsed_time_max = maxval ( elapsed_times ) elapsed_time_min = minval ( elapsed_times ) elapsed_time_average = sum ( elapsed_times ) / num_images () if ( present ( flops )) flops_total = 0.0_rk do i = 1 , num_images () if ( present ( flops )) flops_total = flops_total + this % marks_co ( imark )[ i ]% flops end do end if call co_broadcast ( elapsed_time_average , 1 ) call co_broadcast ( elapsed_time_min , 1 ) call co_broadcast ( elapsed_time_max , 1 ) if ( present ( flops )) call co_broadcast ( flops_total , 1 ) this % marks ( imark )% elapsed_time_average = elapsed_time_average this % marks ( imark )% elapsed_time_min = elapsed_time_min this % marks ( imark )% elapsed_time_max = elapsed_time_max this % marks ( imark )% speedup_max_total = this % marks ( imark )% elapsed_time_max / this % marks ( 1 )% elapsed_time_max if ( this_image () == 1 ) then print '(a,f7.3,a)' , colorize ( ' Elapsed time (max)     :' , color_fg = 'blue' ),& this % marks ( imark )% elapsed_time_max , ' [s]' print '(a,f7.3,a)' , colorize ( ' Elapsed time (min)     :' , color_fg = 'blue' ),& this % marks ( imark )% elapsed_time_min , ' [s]' print '(a,f7.3,a)' , colorize ( ' Elapsed time (average) :' , color_fg = 'blue' ),& this % marks ( imark )% elapsed_time_average , ' [s]' print '(a,f7.3,a)' , colorize ( ' Speedup (max)          :' , color_fg = 'blue' ),& this % marks ( imark )% speedup_max_total , ' [-]' if ( present ( flops )) print '(a,f7.3,a)' , colorize ( ' Performance  (total)   :' , color_fg = 'cyan' ),& flops_total , ' [GFLOPS]' print '(a)' , '' end if if ( present ( flops )) then this % marks ( imark )% flops_total = flops_total else this % marks ( imark )% flops_total = 0.0_rk end if call this % write_benchmark ( imark ) end subroutine stop_benchmark !=============================================================================== !=============================================================================== impure subroutine write_benchmark ( this , imark ) !! author: Seyed Ali Ghasemi class ( benchmark ), intent ( inout ) :: this integer , intent ( in ) :: imark integer :: nunit character ( len = 53 ) :: fmt1 character ( len = 82 ) :: fmt2 integer :: lm logical :: exist integer :: iostat if ( imark <= 0 . or . imark > size ( this % marks )) error stop 'imark is out of range.' lm = 20 - len_trim ( this % marks ( imark )% method ) write ( fmt1 , '(a,g0,a)' )& '(a,' , lm , 'x,3x,E20.14,3x,E20.14,3x,g8.0,3x,*(g8.0,3x))' inquire ( file = this % filename_image , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename_image ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename_image , access = 'append' ) write ( nunit , fmt1 ) & this % marks ( imark )% method ,& this % marks_co ( imark )% time % elapsed_time ,& this % marks_co ( imark )% flops ,& this % nloops ,& this % argi close ( nunit ) if ( this_image () == 1 ) then write ( fmt2 , '(a,g0,a)' )& '(a,' , lm , 'x,3x,F12.6,3x,E20.14,3x,E20.14,3x,E20.14,3x,E20.14,3x,g8.0,3x,*(g8.0,3x))' inquire ( file = this % filename , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename , access = 'append' ) write ( nunit , fmt2 ) & this % marks ( imark )% method ,& this % marks ( imark )% speedup_max_total ,& this % marks ( imark )% elapsed_time_max ,& this % marks ( imark )% elapsed_time_min ,& this % marks ( imark )% elapsed_time_average ,& this % marks ( imark )% flops_total ,& this % nloops ,& this % argi close ( nunit ) end if end subroutine write_benchmark !=============================================================================== !=============================================================================== pure elemental subroutine finalize_mark ( this ) !! author: Seyed Ali Ghasemi class ( mark ), intent ( inout ) :: this if ( allocated ( this % method )) deallocate ( this % method ) if ( allocated ( this % description )) deallocate ( this % description ) end subroutine finalize_mark !=============================================================================== !=============================================================================== elemental impure subroutine finalize ( this ) !! author: Seyed Ali Ghasemi class ( benchmark ), intent ( inout ) :: this integer :: nunit logical :: exist integer :: iostat inquire ( file = this % filename_image , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename_image ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename_image , access = 'append' ) write ( nunit , '(a)' ) 'end of benchmark' close ( nunit ) if ( this_image () == 1 ) then inquire ( file = this % filename , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename , access = 'append' ) write ( nunit , '(a)' ) 'end of benchmark' close ( nunit ) end if if ( allocated ( this % marks_co )) deallocate ( this % marks_co ) call this % marks % finalize_mark () if ( allocated ( this % marks )) deallocate ( this % marks ) if ( allocated ( this % filename_image )) deallocate ( this % filename_image ) if ( allocated ( this % argi )) deallocate ( this % argi ) if ( allocated ( this % argr )) deallocate ( this % argr ) if ( this_image () == 1 ) print '(a)' , 'end of benchmark' end subroutine finalize !=============================================================================== !=============================================================================== impure function current_date_and_time () result ( datetime ) !! author: Seyed Ali Ghasemi character ( 21 ) :: datetime character ( 10 ) :: date character ( 8 ) :: time integer :: values ( 8 ) character ( 4 ) :: year character ( 2 ) :: month , day , hour , minute , second call date_and_time ( values = values ) write ( year , '(i4)' ) values ( 1 ) write ( month , '(i2)' ) values ( 2 ) write ( day , '(i2)' ) values ( 3 ) write ( hour , '(i2)' ) values ( 5 ) write ( minute , '(i2)' ) values ( 6 ) write ( second , '(i2)' ) values ( 7 ) date = year // '.' // month // '.' // day time = hour // ':' // minute // ':' // second datetime = date // ' - ' // time end function current_date_and_time !=============================================================================== #endif end module forbenchmark_coarray","tags":"","loc":"sourcefile/forbenchmark_coarray.f90.html"},{"title":"forbenchmark.f90 – ForBenchmark","text":"This file depends on sourcefile~~forbenchmark.f90~~EfferentGraph sourcefile~forbenchmark.f90 forbenchmark.f90 sourcefile~forbenchmark_coarray.f90 forbenchmark_coarray.f90 sourcefile~forbenchmark.f90->sourcefile~forbenchmark_coarray.f90 sourcefile~forbenchmark_default.f90 forbenchmark_default.f90 sourcefile~forbenchmark.f90->sourcefile~forbenchmark_default.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~forbenchmark.f90~~AfferentGraph sourcefile~forbenchmark.f90 forbenchmark.f90 sourcefile~demo.f90 demo.f90 sourcefile~demo.f90->sourcefile~forbenchmark.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module forbenchmark #if defined(USE_COARRAY) use forbenchmark_coarray #else use forbenchmark_default #endif public benchmark end module forbenchmark","tags":"","loc":"sourcefile/forbenchmark.f90.html"}]}