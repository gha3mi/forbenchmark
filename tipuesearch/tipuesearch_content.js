var tipuesearch = {"pages":[{"title":" ForBenchmark ","text":"ForBenchmark ForBenchmark : A Fortran library for benchmarking (with support for coarrays). ForBenchmark can measure various time metrics including elapsed wall time, CPU time, OpenMP (OMP) time, MPI time, and date_and_time. Furthermore, it can compute flops based on a provided function. Benchmark Results dot_product matmul This list will be updated. Feel free to add new benchmarks. Simple Usage use forbenchmark type ( benchmark ) :: bench ! initialize the benchmark call bench % init ( nmarks ) ! start benchmark call bench % start_benchmark ( imark , method ) ! loop over nloops do nl = 1 , bench % nloops ! call your function or subroutine or ... end do ! stop benchmark call bench % stop_benchmark () ! finalize the benchmark call bench % finalize () Procedures ! initialize the benchmark call bench % init ( nmarks , title , filename , nloops , timer ) ! start benchmark call bench % start_benchmark ( imark , method , description , argi , argr ) ! stop benchmark call bench % stop_benchmark ( flops ) ! finalize the benchmark call bench % finalize () Refer to example/demo.f90 for a complete demonstration. fpm dependency To use ForBenchmark as a dependency in your fpm project, include the following line in your fpm.toml file: [dependencies] forbenchmark = { git = \"https://github.com/gha3mi/forbenchmark.git\" } How to Run the Demo Clone the repository: Clone the ForBenchmark repository from GitHub using: git clone https://github.com/gha3mi/forbenchmark.git cd forbenchmark Run the demo: For non-coarray benchmarking: fpm run --example demo --profile release For coarray programs benchmarking using the Intel Fortran compiler: fpm run --example demo --profile release --compiler ifx --flag \"-coarray -coarray-num-images=4 -DUSE_COARRAY\" fpm run --example demo --profile release --compiler ifort --flag \"-coarray -coarray-num-images=4 -DUSE_COARRAY\" After execution, the results will be displayed in the terminal and stored in the 'results' folder. See results/demo.data , results/demo_im1.data for instance. Visualizing and exporting demo results: To generate visual representations and export benchmarking metrics, execute the following commands in Python. Specify the relevant data file as an argument: python results/export.py demo.data This command will produce graphical representations and an HTML table showcasing benchmarking metrics: For Coarray benchmarks, execute: python results/export_co.py demo_co.data\npython results/export_im.py demo_im1.data The outputs can be found in the results directory. TODO [ ] Add sphinx-gallery [ ] Add settings to set units. [ ] Add benchmarks for matmul_co, dot_co, ... [ ] Add MPI module. API documentation The most up-to-date API documentation for the main branch is available here .\nTo generate the API documentation for ForBenchmark using ford run the following\ncommand: ford ford.yml Contributing Contributions to ForBenchmark are welcome!\nIf you find any issues or would like to suggest improvements, please open an issue. Developer Info Seyed Ali Ghasemi","tags":"home","loc":"index.html"},{"title":"mark – ForBenchmark ","text":"type, private :: mark Derived type for each method being benchmarked. Inherits type~~mark~2~~InheritsGraph type~mark~2 mark timer timer type~mark~2->timer time Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~mark~2~~InheritedByGraph type~mark~2 mark type~benchmark~2 benchmark type~benchmark~2->type~mark~2 marks Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: method Name of the method being benchmarked character(len=:), public, allocatable :: description Description of the method being benchmarked type(timer), public :: time Timer object to measure elapsed time real(kind=rk), public :: elapsed_time Elapsed time for the benchmark real(kind=rk), public :: speedup Speedup relative to a reference benchmark real(kind=rk), public :: flops Floating-point operations per second Type-Bound Procedures procedure, private :: finalize_mark Finalize procedure for mark type private pure elemental subroutine finalize_mark (this) Author Seyed Ali Ghasemi License BSD 3-Clause License Finalizes the mark object by deallocating allocated memory for method and description. Arguments Type Intent Optional Attributes Name class( mark ), intent(inout) :: this Mark object to be finalized Source Code type :: mark !! author: Seyed Ali Ghasemi !! Derived type for each method being benchmarked. !! character (:), allocatable :: method !! Name of the method being benchmarked character (:), allocatable :: description !! Description of the method being benchmarked type ( timer ) :: time !! Timer object to measure elapsed time real ( rk ) :: elapsed_time !! Elapsed time for the benchmark real ( rk ) :: speedup !! Speedup relative to a reference benchmark real ( rk ) :: flops !! Floating-point operations per second contains procedure , private :: finalize_mark !! Finalize procedure for mark type end type mark","tags":"","loc":"type/mark~2.html"},{"title":"benchmark – ForBenchmark ","text":"type, public :: benchmark Derived type for benchmarking and performance evaluation. Inherits type~~benchmark~2~~InheritsGraph type~benchmark~2 benchmark type~mark~2 mark type~benchmark~2->type~mark~2 marks timer timer type~mark~2->timer time Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( mark ), public, dimension(:), allocatable :: marks Array of marks to store benchmark data character(len=:), public, allocatable :: filename Filename for storing benchmark data integer, public :: nloops Number of loops for each benchmark integer(kind=ik), public, dimension(:), allocatable :: argi Integer arguments for benchmarks real(kind=rk), public, dimension(:), allocatable :: argr Real arguments for benchmarks character(len=:), public, allocatable :: timer Timer object for measuring time integer, public :: imark Index of current benchmark mark Type-Bound Procedures procedure, public :: init Initialize the benchmark object private impure elemental subroutine init (this, nmarks, title, filename, nloops, timer) Author Seyed Ali Ghasemi License BSD 3-Clause License Initialize the benchmark object. Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Benchmark object integer, intent(in) :: nmarks Number of methods to be benchmarked character(len=*), intent(in), optional :: title Title of the benchmark character(len=*), intent(in), optional :: filename Filename for storing benchmark data integer, intent(in), optional :: nloops Number of loops for each benchmark (default: 10) character(len=*), intent(in), optional :: timer Timer object for measuring time (default: wall). The timer options available are 'wall', 'date_and_time', 'cpu', 'omp', and 'mpi'. procedure, public :: start_benchmark Start a benchmark private impure subroutine start_benchmark (this, imark, method, description, argi, argr) Author Seyed Ali Ghasemi License BSD 3-Clause License Start a specific benchmark Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Benchmark object integer, intent(in) :: imark Index of the current method character(len=*), intent(in) :: method Name of the method being benchmarked character(len=*), intent(in), optional :: description Description of the method being benchmarked (optional) integer(kind=ik), intent(in), optional, dimension(:) :: argi Integer arguments for the benchmark (optional) real(kind=rk), intent(in), optional, dimension(:) :: argr Real arguments for the benchmark (optional) procedure, public :: stop_benchmark Stop a benchmark private impure subroutine stop_benchmark (this, flops) Author Seyed Ali Ghasemi License BSD 3-Clause License Stops the currently active benchmark, calculates performance metrics, and writes the results to the file and terminal. Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Benchmark object procedure(Fun), optional :: flops Function to calculate Floating Point Operations Per Second (optional) procedure, private :: write_benchmark Write benchmark data to file private impure subroutine write_benchmark (this) Author Seyed Ali Ghasemi License BSD 3-Clause License Writes the benchmark data to a specified file, including method, speedup, elapsed time, flops, and other details. Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Benchmark object procedure, public :: finalize Finalize the benchmark object private impure elemental subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause License Finalizes the benchmark object by deallocating memory and performs necessary cleanup. Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Benchmark object to be finalized Source Code type :: benchmark !! author: Seyed Ali Ghasemi !! Derived type for benchmarking and performance evaluation. !! type ( mark ), dimension (:), allocatable :: marks !! Array of marks to store benchmark data character (:), allocatable :: filename !! Filename for storing benchmark data integer :: nloops !! Number of loops for each benchmark integer ( ik ), dimension (:), allocatable :: argi !! Integer arguments for benchmarks real ( rk ), dimension (:), allocatable :: argr !! Real arguments for benchmarks character (:), allocatable :: timer !! Timer object for measuring time integer :: imark !! Index of current benchmark mark contains procedure :: init !! Initialize the benchmark object procedure :: start_benchmark !! Start a benchmark procedure :: stop_benchmark !! Stop a benchmark procedure , private :: write_benchmark !! Write benchmark data to file procedure :: finalize !! Finalize the benchmark object end type benchmark","tags":"","loc":"type/benchmark~2.html"},{"title":"mark_co – ForBenchmark ","text":"type, private :: mark_co Derived type for each method being benchmarked in each image. Inherits type~~mark_co~~InheritsGraph type~mark_co mark_co timer timer type~mark_co->timer time Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~mark_co~~InheritedByGraph type~mark_co mark_co type~benchmark benchmark type~benchmark->type~mark_co marks_co Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(timer), public :: time Timer object to measure elapsed time in each image real(kind=rk), public :: elapsed_time Elapsed time for the benchmark in each image real(kind=rk), public :: flops Floating-point operations per second in each image Source Code type :: mark_co !! author: Seyed Ali Ghasemi !! Derived type for each method being benchmarked in each image. !! type ( timer ) :: time !! Timer object to measure elapsed time in each image real ( rk ) :: elapsed_time !! Elapsed time for the benchmark in each image real ( rk ) :: flops !! Floating-point operations per second in each image end type mark_co","tags":"","loc":"type/mark_co.html"},{"title":"mark – ForBenchmark ","text":"type, private :: mark Derived type for each method being benchmarked in all images. Inherited by type~~mark~~InheritedByGraph type~mark mark type~benchmark benchmark type~benchmark->type~mark marks Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: method Name of the method being benchmarked character(len=:), public, allocatable :: description Description of the method being benchmarked real(kind=rk), public :: elapsed_time_min Minimum elapsed time for the benchmark in all images real(kind=rk), public :: elapsed_time_average Average elapsed time for the benchmark in all images real(kind=rk), public :: elapsed_time_max Maximum elapsed time for the benchmark in all images real(kind=rk), public :: flops_total Total floating-point operations per second in all images real(kind=rk), public :: speedup_max_total Maximum speedup in all images compared to the reference benchmark Type-Bound Procedures procedure, private :: finalize_mark Finalize procedure for mark type private pure elemental subroutine finalize_mark (this) Author Seyed Ali Ghasemi License BSD 3-Clause License Finalizes the mark object by deallocating allocated memory for method and description. Arguments Type Intent Optional Attributes Name class( mark ), intent(inout) :: this Mark object to be finalized Source Code type :: mark !! author: Seyed Ali Ghasemi !! Derived type for each method being benchmarked in all images. !! character (:), allocatable :: method !! Name of the method being benchmarked character (:), allocatable :: description !! Description of the method being benchmarked real ( rk ) :: elapsed_time_min !! Minimum elapsed time for the benchmark in all images real ( rk ) :: elapsed_time_average !! Average elapsed time for the benchmark in all images real ( rk ) :: elapsed_time_max !! Maximum elapsed time for the benchmark in all images real ( rk ) :: flops_total !! Total floating-point operations per second in all images real ( rk ) :: speedup_max_total !! Maximum speedup in all images compared to the reference benchmark contains procedure , private :: finalize_mark !! Finalize procedure for mark type end type mark","tags":"","loc":"type/mark.html"},{"title":"benchmark – ForBenchmark ","text":"type, public :: benchmark Derived type for benchmarking and performance evaluation. Inherits type~~benchmark~~InheritsGraph type~benchmark benchmark type~mark mark type~benchmark->type~mark marks type~mark_co mark_co type~benchmark->type~mark_co marks_co timer timer type~mark_co->timer time Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( mark_co ), public, dimension(:), allocatable :: marks_co [:] Array of mark_co type for each method being benchmarked in each image type( mark ), public, dimension(:), allocatable :: marks Array of mark type for each method being benchmarked in all images character(len=:), public, allocatable :: filename Filename for storing the benchmark data in all images character(len=:), public, allocatable :: filename_image Filename for storing the benchmark data in each image integer, public :: nloops Number of loops for each benchmark integer(kind=ik), public, dimension(:), allocatable :: argi Integer arguments for benchmarks real(kind=rk), public, dimension(:), allocatable :: argr Real arguments for benchmarks character(len=:), public, allocatable :: timer Timer object for measuring time integer, public :: imark Index of the current benchmark Type-Bound Procedures procedure, public :: init Initialization the benchmark object private impure elemental subroutine init (this, nmarks, title, filename, nloops, timer) Author Seyed Ali Ghasemi License BSD 3-Clause License Initialize the benchmark object. Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Benchmark object integer, intent(in) :: nmarks Number of methods being benchmarked character(len=*), intent(in), optional :: title Title of the benchmark character(len=*), intent(in), optional :: filename Filename for storing the benchmark data integer, intent(in), optional :: nloops Number of loops for each benchmark (default: 10) character(len=*), intent(in), optional :: timer Timer object for measuring time (default: wall) procedure, public :: start_benchmark Start a benchmark private impure subroutine start_benchmark (this, imark, method, description, argi, argr) Author Seyed Ali Ghasemi License BSD 3-Clause License Start a specific benchmark. Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Benchmark object integer, intent(in) :: imark Index of the current method character(len=*), intent(in) :: method Name of the method being benchmarked character(len=*), intent(in), optional :: description Description of the method being benchmarked (optional) integer(kind=ik), intent(in), optional, dimension(:) :: argi Integer arguments for benchmarks (optional) real(kind=rk), intent(in), optional, dimension(:) :: argr Real arguments for benchmarks (optional) procedure, public :: stop_benchmark Stop a benchmark private impure subroutine stop_benchmark (this, flops) Author Seyed Ali Ghasemi License BSD 3-Clause License Stops the currently active benchmark, calculates performance metrics, and writes the results to the file and terminal. Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Benchmark object procedure(Fun), optional :: flops Function to calculate Floating Point Operations Per Second (optional) procedure, private :: write_benchmark Write benchmark data to file private impure subroutine write_benchmark (this) Author Seyed Ali Ghasemi License BSD 3-Clause License Writes the benchmark data to a specified file, including method, speedup, elapsed time, flops, and other details. Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Benchmark object procedure, public :: finalize Finalize the benchmark object private impure elemental subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause License Finalizes the benchmark object by deallocating memory and performs necessary cleanup. Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Benchmark object to be finalized Source Code type :: benchmark !! author: Seyed Ali Ghasemi !! Derived type for benchmarking and performance evaluation. !! type ( mark_co ), dimension (:), allocatable :: marks_co [:] !! Array of mark_co type for each method being benchmarked in each image type ( mark ), dimension (:), allocatable :: marks !! Array of mark type for each method being benchmarked in all images character (:), allocatable :: filename !! Filename for storing the benchmark data in all images character (:), allocatable :: filename_image !! Filename for storing the benchmark data in each image integer :: nloops !! Number of loops for each benchmark integer ( ik ), dimension (:), allocatable :: argi !! Integer arguments for benchmarks real ( rk ), dimension (:), allocatable :: argr !! Real arguments for benchmarks character (:), allocatable :: timer !! Timer object for measuring time integer :: imark !! Index of the current benchmark contains procedure :: init !! Initialization the benchmark object procedure :: start_benchmark !! Start a benchmark procedure :: stop_benchmark !! Stop a benchmark procedure , private :: write_benchmark !! Write benchmark data to file procedure :: finalize !! Finalize the benchmark object end type benchmark","tags":"","loc":"type/benchmark.html"},{"title":"current_date_and_time – ForBenchmark","text":"private impure function current_date_and_time() result(datetime) Retrieves the current date and time and returns it as a string\nIt utilizes the intrinsic date_and_time function to obtain system time information.\nA string containing the current date and time in the format \"YYYY.MM.DD - HH:MM:SS\". Arguments None Return Value character(len=21) Character containing the current date and time Called by proc~~current_date_and_time~~CalledByGraph proc~current_date_and_time forbenchmark_default::current_date_and_time proc~init forbenchmark_default::benchmark%init proc~init->proc~current_date_and_time program~demo demo program~demo->proc~init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure function current_date_and_time () result ( datetime ) !! author: Seyed Ali Ghasemi !! Retrieves the current date and time and returns it as a string !! It utilizes the intrinsic `date_and_time` function to obtain system time information. !! A string containing the current date and time in the format \"YYYY.MM.DD - HH:MM:SS\". !! character ( 21 ) :: datetime !! Character containing the current date and time character ( 10 ) :: date !! Character containing the current date character ( 8 ) :: time !! Character containing the current time integer :: values ( 8 ) !! Array containing the current date and time values character ( 4 ) :: year !! Current year character ( 2 ) :: month !! Current month character ( 2 ) :: day !! Current day character ( 2 ) :: hour !! Current hour character ( 2 ) :: minute !! Current minute character ( 2 ) :: second !! Current second call date_and_time ( values = values ) write ( year , '(i4)' ) values ( 1 ) write ( month , '(i2)' ) values ( 2 ) write ( day , '(i2)' ) values ( 3 ) write ( hour , '(i2)' ) values ( 5 ) write ( minute , '(i2)' ) values ( 6 ) write ( second , '(i2)' ) values ( 7 ) date = year // '.' // month // '.' // day time = hour // ':' // minute // ':' // second datetime = date // ' - ' // time end function current_date_and_time","tags":"","loc":"proc/current_date_and_time.html"},{"title":"init – ForBenchmark","text":"private impure elemental subroutine init(this, nmarks, title, filename, nloops, timer) Uses iso_fortran_env proc~~init~~UsesGraph proc~init forbenchmark_default::benchmark%init iso_fortran_env iso_fortran_env proc~init->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Initialize the benchmark object. Type Bound benchmark Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Benchmark object integer, intent(in) :: nmarks Number of methods to be benchmarked character(len=*), intent(in), optional :: title Title of the benchmark character(len=*), intent(in), optional :: filename Filename for storing benchmark data integer, intent(in), optional :: nloops Number of loops for each benchmark (default: 10) character(len=*), intent(in), optional :: timer Timer object for measuring time (default: wall). The timer options available are 'wall', 'date_and_time', 'cpu', 'omp', and 'mpi'. Calls proc~~init~~CallsGraph proc~init forbenchmark_default::benchmark%init proc~current_date_and_time forbenchmark_default::current_date_and_time proc~init->proc~current_date_and_time Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~init~~CalledByGraph proc~init forbenchmark_default::benchmark%init program~demo demo program~demo->proc~init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental impure subroutine init ( this , nmarks , title , filename , nloops , timer ) !! author: Seyed Ali Ghasemi !! Initialize the benchmark object. !! use , intrinsic :: iso_fortran_env , only : compiler_version , compiler_options class ( benchmark ), intent ( inout ) :: this !! Benchmark object integer , intent ( in ) :: nmarks !! Number of methods to be benchmarked character ( * ), intent ( in ), optional :: title !! Title of the benchmark character ( * ), intent ( in ), optional :: filename !! Filename for storing benchmark data integer , intent ( in ), optional :: nloops !! Number of loops for each benchmark (default: 10) character ( * ), intent ( in ), optional :: timer !! Timer object for measuring time (default: wall). The timer options available are 'wall', 'date_and_time', 'cpu', 'omp', and 'mpi'. integer :: nunit !! Unit number for file access integer :: iostat !! I/O status integer :: which_compiler !! Logical variables for compiler detection character (:), allocatable :: compiler !! Compiler name if ( nmarks <= 0 ) error stop 'nmarks must be greater than zero.' allocate ( this % marks ( nmarks )) compiler = '' which_compiler = index ( compiler_version (), 'Intel(R) Fortran Compiler' ) if ( which_compiler /= 0 ) compiler = '_ifx' which_compiler = index ( compiler_version (), 'Intel(R) Fortran Intel(R)' ) if ( which_compiler /= 0 ) compiler = '_ifort' which_compiler = index ( compiler_version (), 'GCC' ) if ( which_compiler /= 0 ) compiler = '_gfortran' which_compiler = index ( compiler_version (), 'nvfortran' ) if ( which_compiler /= 0 ) compiler = '_nvfortran' if ( present ( filename )) then this % filename = trim ( filename // compiler // '.data' ) else this % filename = 'benchmark' // compiler // '.data' endif if ( present ( nloops )) then if ( nloops <= 0 ) error stop 'nloops must be greater than zero.' this % nloops = nloops else this % nloops = 10 end if if ( present ( timer )) then select case ( trim ( timer )) case ( 'wall' ) this % timer = 'wall' case ( 'date_and_time' ) this % timer = 'date_and_time' case ( 'cpu' ) this % timer = 'cpu' case ( 'omp' ) #if defined(USE_OMP) this % timer = 'omp' #else error stop 'Use -DUSE_OMP to enable OpenMP.' #endif case ( 'mpi' ) #if defined(USE_MPI) this % timer = 'mpi' #else error stop 'Use -DUSE_MPI to enable MPI.' #endif case default error stop 'timer is not valid. Valid options are: wall, date_and_time, cpu, omp, mpi.' end select else this % timer = 'wall' end if inquire ( file = this % filename , iostat = iostat ) if ( iostat /= 0 ) then error stop 'file ' // trim ( this % filename ) // ' cannot be accessed.' end if open ( newunit = nunit , file = this % filename ) write ( nunit , '(a)' ) '-----------------------------------------------------' write ( nunit , '(a)' ) 'ForBenchmark - https://github.com/gha3mi/forbenchmark' write ( nunit , '(a)' ) '-----------------------------------------------------' write ( nunit , '(a)' ) '' if ( present ( title )) then write ( nunit , '(a)' ) trim ( title ) else write ( nunit , '(a)' ) 'ForBenchmark' endif write ( nunit , '(a)' ) current_date_and_time () write ( nunit , '(a)' ) '' write ( nunit , '(a,a)' ) 'compiler_version: ' , compiler_version () write ( nunit , '(a,a)' ) 'compiler_options: ' , compiler_options () write ( nunit , '(a)' ) '' write ( nunit , '(a)' ) '' write ( nunit , '(a)' ) & & '       METHOD        |& &   SPEEDUP    |& &         TIME         |& &        GFLOPS        |& &  NLOOPS  |& &   ARGI  ' close ( nunit ) end subroutine init","tags":"","loc":"proc/init.html"},{"title":"start_benchmark – ForBenchmark","text":"private impure subroutine start_benchmark(this, imark, method, description, argi, argr) Uses face proc~~start_benchmark~~UsesGraph proc~start_benchmark forbenchmark_default::benchmark%start_benchmark face face proc~start_benchmark->face Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Start a specific benchmark Type Bound benchmark Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Benchmark object integer, intent(in) :: imark Index of the current method character(len=*), intent(in) :: method Name of the method being benchmarked character(len=*), intent(in), optional :: description Description of the method being benchmarked (optional) integer(kind=ik), intent(in), optional, dimension(:) :: argi Integer arguments for the benchmark (optional) real(kind=rk), intent(in), optional, dimension(:) :: argr Real arguments for the benchmark (optional) Calls proc~~start_benchmark~~CallsGraph proc~start_benchmark forbenchmark_default::benchmark%start_benchmark colorize colorize proc~start_benchmark->colorize ctimer_start ctimer_start proc~start_benchmark->ctimer_start dtimer_start dtimer_start proc~start_benchmark->dtimer_start mtimer_start mtimer_start proc~start_benchmark->mtimer_start otimer_start otimer_start proc~start_benchmark->otimer_start timer_start timer_start proc~start_benchmark->timer_start Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~start_benchmark~~CalledByGraph proc~start_benchmark forbenchmark_default::benchmark%start_benchmark program~demo demo program~demo->proc~start_benchmark Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine start_benchmark ( this , imark , method , description , argi , argr ) !! author: Seyed Ali Ghasemi !! Start a specific benchmark !! use face class ( benchmark ), intent ( inout ) :: this !! Benchmark object integer , intent ( in ) :: imark !! Index of the current method character ( * ), intent ( in ) :: method !! Name of the method being benchmarked integer ( ik ), dimension (:), intent ( in ), optional :: argi !! Integer arguments for the benchmark (optional) real ( rk ), dimension (:), intent ( in ), optional :: argr !! Real arguments for the benchmark (optional) character ( * ), intent ( in ), optional :: description !! Description of the method being benchmarked (optional) if ( imark <= 0 . or . imark > size ( this % marks )) error stop 'imark is out of range.' this % imark = imark this % marks ( this % imark )% description = description this % marks ( this % imark )% method = method if ( present ( argi )) then this % argi = argi else if (. not . allocated ( this % argi )) allocate ( this % argi ( 0 )) endif if ( present ( argr )) then this % argr = argr else if (. not . allocated ( this % argr )) allocate ( this % argr ( 0 )) endif if ( present ( description ) . and . present ( argi )) then print '(a,a,\" \",a,*(g0,1x))' ,& colorize ( 'Meth.: ' // this % marks ( this % imark )% method , color_fg = 'green' , style = 'bold_on' ),& colorize ( '; Des.: ' // this % marks ( this % imark )% description , color_fg = 'green_intense' ),& '; Argi.:' ,& this % argi elseif ( present ( description ) . and . . not . present ( argi )) then print '(a,a,\" \",a)' ,& colorize ( 'Meth.: ' // this % marks ( this % imark )% method , color_fg = 'green' , style = 'bold_on' ),& colorize ( '; Des.: ' // this % marks ( this % imark )% description , color_fg = 'green_intense' ) elseif (. not . present ( description ) . and . present ( argi )) then print '(a,a,*(g0,1x))' ,& colorize ( 'Meth.: ' // this % marks ( this % imark )% method , color_fg = 'green' , style = 'bold_on' ),& '; Argi.:' ,& this % argi else print '(a)' , colorize ( 'Meth.: ' // this % marks ( this % imark )% method , color_fg = 'green' , style = 'bold_on' ) end if select case ( trim ( this % timer )) case ( 'wall' ) call this % marks ( this % imark )% time % timer_start () case ( 'date_and_time' ) call this % marks ( this % imark )% time % dtimer_start () case ( 'cpu' ) call this % marks ( this % imark )% time % ctimer_start () case ( 'omp' ) #if defined(USE_OMP) call this % marks ( this % imark )% time % otimer_start () #else error stop 'Use -DUSE_OMP to enable OpenMP.' #endif case ( 'mpi' ) #if defined(USE_MPI) call this % marks ( this % imark )% time % mtimer_start () #else error stop 'Use -DUSE_MPI to enable MPI.' #endif end select end subroutine start_benchmark","tags":"","loc":"proc/start_benchmark.html"},{"title":"stop_benchmark – ForBenchmark","text":"private impure subroutine stop_benchmark(this, flops) Stops the currently active benchmark, calculates performance metrics, and writes the results to the file and terminal. Type Bound benchmark Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Benchmark object procedure(Fun), optional :: flops Function to calculate Floating Point Operations Per Second (optional) Calls proc~~stop_benchmark~~CallsGraph proc~stop_benchmark forbenchmark_default::benchmark%stop_benchmark ctimer_stop ctimer_stop proc~stop_benchmark->ctimer_stop dtimer_stop dtimer_stop proc~stop_benchmark->dtimer_stop mtimer_stop mtimer_stop proc~stop_benchmark->mtimer_stop otimer_stop otimer_stop proc~stop_benchmark->otimer_stop proc~write_benchmark forbenchmark_default::benchmark%write_benchmark proc~stop_benchmark->proc~write_benchmark timer_stop timer_stop proc~stop_benchmark->timer_stop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~stop_benchmark~~CalledByGraph proc~stop_benchmark forbenchmark_default::benchmark%stop_benchmark program~demo demo program~demo->proc~stop_benchmark Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine stop_benchmark ( this , flops ) !! author: Seyed Ali Ghasemi !! Stops the currently active benchmark, calculates performance metrics, and writes the results to the file and terminal. !! interface impure function Fun ( argi , argr ) import rk , ik integer ( ik ), dimension (:), intent ( in ), optional :: argi real ( rk ), dimension (:), intent ( in ), optional :: argr real ( rk ) :: Fun end function Fun end interface procedure ( Fun ), optional :: flops !! Function to calculate Floating Point Operations Per Second (optional) class ( benchmark ), intent ( inout ) :: this !! Benchmark object select case ( trim ( this % timer )) case ( 'wall' ) call this % marks ( this % imark )% time % timer_stop ( message = ' Elapsed time :' , nloops = this % nloops ) this % marks ( this % imark )% elapsed_time = this % marks ( this % imark )% time % elapsed_time case ( 'date_and_time' ) call this % marks ( this % imark )% time % dtimer_stop ( message = ' Elapsed time :' , nloops = this % nloops ) this % marks ( this % imark )% elapsed_time = this % marks ( this % imark )% time % elapsed_dtime case ( 'cpu' ) call this % marks ( this % imark )% time % ctimer_stop ( message = ' Elapsed time :' , nloops = this % nloops ) this % marks ( this % imark )% elapsed_time = this % marks ( this % imark )% time % cpu_time case ( 'omp' ) #if defined(USE_OMP) call this % marks ( this % imark )% time % otimer_stop ( message = ' Elapsed time :' , nloops = this % nloops ) this % marks ( this % imark )% elapsed_time = this % marks ( this % imark )% time % omp_time #else error stop 'Use -DUSE_OMP to enable OpenMP.' #endif case ( 'mpi' ) #if defined(USE_MPI) call this % marks ( this % imark )% time % mtimer_stop ( message = ' Elapsed time :' , nloops = this % nloops ) this % marks ( this % imark )% elapsed_time = this % marks ( this % imark )% time % mpi_time #else error stop 'Use -DUSE_MPI to enable MPI.' #endif end select if ( this % marks ( this % imark )% elapsed_time <= epsilon ( 0.0_rk )) error stop 'Elapsed time is too small' this % marks ( this % imark )% speedup = this % marks ( 1 )% elapsed_time / this % marks ( this % imark )% elapsed_time if ( present ( flops )) then print '(a,f7.3,a)' , ' Speedup      :' , this % marks ( this % imark )% speedup , ' [-]' this % marks ( this % imark )% flops = flops ( this % argi , this % argr ) / this % marks ( this % imark )% elapsed_time print '(a,f7.3,a)' , ' Performance  :' , this % marks ( this % imark )% flops , ' [GFLOPS]' else this % marks ( this % imark )% flops = 0.0_rk endif print '(a)' , '' call this % write_benchmark () end subroutine stop_benchmark","tags":"","loc":"proc/stop_benchmark.html"},{"title":"write_benchmark – ForBenchmark","text":"private impure subroutine write_benchmark(this) Writes the benchmark data to a specified file, including method, speedup, elapsed time, flops, and other details. Type Bound benchmark Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Benchmark object Called by proc~~write_benchmark~~CalledByGraph proc~write_benchmark forbenchmark_default::benchmark%write_benchmark proc~stop_benchmark forbenchmark_default::benchmark%stop_benchmark proc~stop_benchmark->proc~write_benchmark program~demo demo program~demo->proc~stop_benchmark Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine write_benchmark ( this ) !! author: Seyed Ali Ghasemi !! Writes the benchmark data to a specified file, including method, speedup, elapsed time, flops, and other details. !! class ( benchmark ), intent ( inout ) :: this !! Benchmark object integer :: nunit !! Unit number for file access character ( len = 65 ) :: fmt !! Format for write logical :: exist !! Logical variable for file existence integer :: iostat !! I/O status integer :: lm inquire ( file = this % filename , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename , access = 'append' ) lm = 20 - len_trim ( this % marks ( this % imark )% method ) write ( fmt , '(a,g0,a)' ) '(a,' , lm , 'x,3x,F12.6,3x,E20.14,3x,E20.14,3x,g8.0,3x,*(g20.0,3x))' write ( nunit , fmt ) & this % marks ( this % imark )% method ,& this % marks ( this % imark )% speedup ,& this % marks ( this % imark )% elapsed_time ,& this % marks ( this % imark )% flops ,& this % nloops ,& this % argi close ( nunit ) end subroutine write_benchmark","tags":"","loc":"proc/write_benchmark.html"},{"title":"finalize_mark – ForBenchmark","text":"private pure elemental subroutine finalize_mark(this) Finalizes the mark object by deallocating allocated memory for method and description. Type Bound mark Arguments Type Intent Optional Attributes Name class( mark ), intent(inout) :: this Mark object to be finalized Called by proc~~finalize_mark~~CalledByGraph proc~finalize_mark forbenchmark_default::mark%finalize_mark proc~finalize forbenchmark_default::benchmark%finalize proc~finalize->proc~finalize_mark program~demo demo program~demo->proc~finalize Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental pure subroutine finalize_mark ( this ) !! author: Seyed Ali Ghasemi !! Finalizes the mark object by deallocating allocated memory for method and description. !! class ( mark ), intent ( inout ) :: this !! Mark object to be finalized if ( allocated ( this % method )) deallocate ( this % method ) if ( allocated ( this % description )) deallocate ( this % description ) end subroutine finalize_mark","tags":"","loc":"proc/finalize_mark.html"},{"title":"finalize – ForBenchmark","text":"private impure elemental subroutine finalize(this) Finalizes the benchmark object by deallocating memory and performs necessary cleanup. Type Bound benchmark Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Benchmark object to be finalized Calls proc~~finalize~~CallsGraph proc~finalize forbenchmark_default::benchmark%finalize proc~finalize_mark forbenchmark_default::mark%finalize_mark proc~finalize->proc~finalize_mark Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~finalize~~CalledByGraph proc~finalize forbenchmark_default::benchmark%finalize program~demo demo program~demo->proc~finalize Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental impure subroutine finalize ( this ) !! author: Seyed Ali Ghasemi !! Finalizes the benchmark object by deallocating memory and performs necessary cleanup. !! class ( benchmark ), intent ( inout ) :: this !! Benchmark object to be finalized integer :: nunit !! Unit number for file access logical :: exist !! Logical variable for file existence integer :: iostat !! I/O status inquire ( file = this % filename , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename , access = 'append' ) write ( nunit , '(a)' ) 'end of benchmark' close ( nunit ) call this % marks (:)% finalize_mark () if ( allocated ( this % filename )) deallocate ( this % filename ) if ( allocated ( this % argi )) deallocate ( this % argi ) if ( allocated ( this % argr )) deallocate ( this % argr ) print '(a)' , 'end of benchmark' end subroutine finalize","tags":"","loc":"proc/finalize.html"},{"title":"current_date_and_time – ForBenchmark","text":"private impure function current_date_and_time() result(datetime) Retrieves the current date and time and returns it as a string\nIt utilizes the intrinsic date_and_time function to obtain system time information.\nA string containing the current date and time in the format \"YYYY.MM.DD - HH:MM:SS\". Arguments None Return Value character(len=21) Character containing the current date and time Called by proc~~current_date_and_time~2~~CalledByGraph proc~current_date_and_time~2 forbenchmark_coarray::current_date_and_time proc~init~2 forbenchmark_coarray::benchmark%init proc~init~2->proc~current_date_and_time~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure function current_date_and_time () result ( datetime ) !! author: Seyed Ali Ghasemi !! Retrieves the current date and time and returns it as a string !! It utilizes the intrinsic `date_and_time` function to obtain system time information. !! A string containing the current date and time in the format \"YYYY.MM.DD - HH:MM:SS\". !! character ( 21 ) :: datetime !! Character containing the current date and time character ( 10 ) :: date !! Character containing the current date character ( 8 ) :: time !! Character containing the current time integer :: values ( 8 ) !! Array containing the current date and time values character ( 4 ) :: year !! Current year character ( 2 ) :: month !! Current month character ( 2 ) :: day !! Current day character ( 2 ) :: hour !! Current hour character ( 2 ) :: minute !! Current minute character ( 2 ) :: second !! Current second call date_and_time ( values = values ) write ( year , '(i4)' ) values ( 1 ) write ( month , '(i2)' ) values ( 2 ) write ( day , '(i2)' ) values ( 3 ) write ( hour , '(i2)' ) values ( 5 ) write ( minute , '(i2)' ) values ( 6 ) write ( second , '(i2)' ) values ( 7 ) date = year // '.' // month // '.' // day time = hour // ':' // minute // ':' // second datetime = date // ' - ' // time end function current_date_and_time","tags":"","loc":"proc/current_date_and_time~2.html"},{"title":"init – ForBenchmark","text":"private impure elemental subroutine init(this, nmarks, title, filename, nloops, timer) Uses iso_fortran_env proc~~init~2~~UsesGraph proc~init~2 forbenchmark_coarray::benchmark%init iso_fortran_env iso_fortran_env proc~init~2->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Initialize the benchmark object. Type Bound benchmark Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Benchmark object integer, intent(in) :: nmarks Number of methods being benchmarked character(len=*), intent(in), optional :: title Title of the benchmark character(len=*), intent(in), optional :: filename Filename for storing the benchmark data integer, intent(in), optional :: nloops Number of loops for each benchmark (default: 10) character(len=*), intent(in), optional :: timer Timer object for measuring time (default: wall) Calls proc~~init~2~~CallsGraph proc~init~2 forbenchmark_coarray::benchmark%init proc~current_date_and_time~2 forbenchmark_coarray::current_date_and_time proc~init~2->proc~current_date_and_time~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental impure subroutine init ( this , nmarks , title , filename , nloops , timer ) !! author: Seyed Ali Ghasemi !! Initialize the benchmark object. !! use , intrinsic :: iso_fortran_env , only : compiler_version , compiler_options class ( benchmark ), intent ( inout ) :: this !! Benchmark object integer , intent ( in ) :: nmarks !! Number of methods being benchmarked character ( * ), intent ( in ), optional :: title !! Title of the benchmark character ( * ), intent ( in ), optional :: filename !! Filename for storing the benchmark data integer , intent ( in ), optional :: nloops !! Number of loops for each benchmark (default: 10) character ( * ), intent ( in ), optional :: timer !! Timer object for measuring time (default: wall) integer :: nunit !! Unit number for file access integer :: iostat !! I/O status character ( 10 ) :: im_chr !! Character representation of the image number integer :: which_compiler !! Logical variables for compiler detection character (:), allocatable :: compiler !! Compiler name if ( nmarks <= 0 ) error stop 'nmarks must be greater than zero.' compiler = '' which_compiler = index ( compiler_version (), 'Intel(R) Fortran Compiler' ) if ( which_compiler /= 0 ) compiler = '_ifx' which_compiler = index ( compiler_version (), 'Intel(R) Fortran Intel(R)' ) if ( which_compiler /= 0 ) compiler = '_ifort' which_compiler = index ( compiler_version (), 'GCC' ) if ( which_compiler /= 0 ) compiler = '_gfortran' which_compiler = index ( compiler_version (), 'nvfortran' ) if ( which_compiler /= 0 ) compiler = '_nvfortran' write ( im_chr , '(i0)' ) this_image () if ( present ( filename )) then this % filename_image = trim ( filename // compiler // '_im' // trim ( im_chr ) // '.data' ) this % filename = trim ( filename // compiler // '_co' // '.data' ) else this % filename_image = trim ( 'benchmark' // compiler // '_im' // trim ( im_chr ) // '.data' ) this % filename = trim ( 'benchmark' // compiler // '_co' // '.data' ) end if if ( present ( nloops )) then if ( nloops <= 0 ) error stop 'nloops must be greater than zero.' this % nloops = nloops else this % nloops = 10 end if if ( present ( timer )) then select case ( trim ( timer )) case ( 'wall' ) this % timer = 'wall' case ( 'date_and_time' ) this % timer = 'date_and_time' case ( 'cpu' ) this % timer = 'cpu' case ( 'omp' ) #if defined(USE_OMP) this % timer = 'omp' #else error stop 'Use -DUSE_OMP to enable OpenMP.' #endif case ( 'mpi' ) #if defined(USE_MPI) this % timer = 'mpi' #else error stop 'Use -DUSE_MPI to enable MPI.' #endif case default error stop 'timer is not valid. Valid options are: wall, date_and_time, cpu, omp, mpi.' end select else this % timer = 'wall' end if allocate ( this % marks_co ( nmarks )[ * ]) allocate ( this % marks ( nmarks )) inquire ( file = this % filename_image , iostat = iostat ) if ( iostat /= 0 ) then error stop 'file ' // trim ( this % filename_image ) // ' cannot be accessed.' end if open ( newunit = nunit , file = this % filename_image ) write ( nunit , '(a)' ) '-----------------------------------------------------' write ( nunit , '(a)' ) 'ForBenchmark - https://github.com/gha3mi/forbenchmark' write ( nunit , '(a)' ) '-----------------------------------------------------' write ( nunit , '(a)' ) '' if ( present ( title )) then write ( nunit , '(a)' ) trim ( title ) else write ( nunit , '(a)' ) 'ForBenchmark' end if write ( nunit , '(a)' ) current_date_and_time () write ( nunit , '(a)' ) '' write ( nunit , '(a,a)' ) 'compiler_version: ' , compiler_version () write ( nunit , '(a,a)' ) 'compiler_options: ' , compiler_options () write ( nunit , '(a,g0,a,g0)' ) 'image: ' , this_image (), ' of ' , num_images () write ( nunit , '(a)' ) '' write ( nunit , '(a)' ) & & '       METHOD        |& &     TIME(image)      |& &    GFLOPS(image)     |& &  NLOOPS  |& &   ARGI  ' close ( nunit ) if ( this_image () == 1 ) then inquire ( file = this % filename , iostat = iostat ) if ( iostat /= 0 ) then error stop 'file ' // trim ( this % filename ) // ' cannot be accessed.' end if open ( newunit = nunit , file = this % filename ) write ( nunit , '(a)' ) '-----------------------------------------------------' write ( nunit , '(a)' ) 'ForBenchmark - https://github.com/gha3mi/forbenchmark' write ( nunit , '(a)' ) '-----------------------------------------------------' write ( nunit , '(a)' ) '' if ( present ( title )) then write ( nunit , '(a)' ) trim ( title ) else write ( nunit , '(a)' ) 'ForBenchmark' end if write ( nunit , '(a)' ) current_date_and_time () write ( nunit , '(a)' ) '' write ( nunit , '(a,a)' ) 'compiler_version: ' , compiler_version () write ( nunit , '(a,a)' ) 'compiler_options: ' , compiler_options () write ( nunit , '(a,g0)' ) 'num_image: ' , num_images () write ( nunit , '(a)' ) '' write ( nunit , '(a)' ) & & '       METHOD        |& & SPEEDUP(max) |& &      TIME(max)       |& &      TIME(min)       |& &      TIME(avg)       |& &     GFLOPS(tot)      |& &  NLOOPS  |& &   ARGI  ' close ( nunit ) end if end subroutine init","tags":"","loc":"proc/init~2.html"},{"title":"start_benchmark – ForBenchmark","text":"private impure subroutine start_benchmark(this, imark, method, description, argi, argr) Uses face proc~~start_benchmark~2~~UsesGraph proc~start_benchmark~2 forbenchmark_coarray::benchmark%start_benchmark face face proc~start_benchmark~2->face Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Start a specific benchmark. Type Bound benchmark Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Benchmark object integer, intent(in) :: imark Index of the current method character(len=*), intent(in) :: method Name of the method being benchmarked character(len=*), intent(in), optional :: description Description of the method being benchmarked (optional) integer(kind=ik), intent(in), optional, dimension(:) :: argi Integer arguments for benchmarks (optional) real(kind=rk), intent(in), optional, dimension(:) :: argr Real arguments for benchmarks (optional) Calls proc~~start_benchmark~2~~CallsGraph proc~start_benchmark~2 forbenchmark_coarray::benchmark%start_benchmark colorize colorize proc~start_benchmark~2->colorize ctimer_start ctimer_start proc~start_benchmark~2->ctimer_start dtimer_start dtimer_start proc~start_benchmark~2->dtimer_start mtimer_start mtimer_start proc~start_benchmark~2->mtimer_start ptimer_start ptimer_start proc~start_benchmark~2->ptimer_start timer_start timer_start proc~start_benchmark~2->timer_start Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine start_benchmark ( this , imark , method , description , argi , argr ) !! author: Seyed Ali Ghasemi !! Start a specific benchmark. !! use face class ( benchmark ), intent ( inout ) :: this !! Benchmark object integer , intent ( in ) :: imark !! Index of the current method character ( * ), intent ( in ) :: method !! Name of the method being benchmarked integer ( ik ), dimension (:), intent ( in ), optional :: argi !! Integer arguments for benchmarks (optional) real ( rk ), dimension (:), intent ( in ), optional :: argr !! Real arguments for benchmarks (optional) character ( * ), intent ( in ), optional :: description !! Description of the method being benchmarked (optional) if ( imark <= 0 . or . imark > size ( this % marks )) error stop 'imark is out of range.' this % imark = imark this % marks ( this % imark )% description = description this % marks ( this % imark )% method = method if ( present ( argi )) then this % argi = argi else if (. not . allocated ( this % argi )) allocate ( this % argi ( 0 )) endif if ( present ( argr )) then this % argr = argr else if (. not . allocated ( this % argr )) allocate ( this % argr ( 0 )) endif sync all if ( present ( description ) . and . present ( argi ) . and . this_image () == 1 ) then print '(a,a,\" \",a,*(g0,1x))' ,& colorize ( 'Meth.: ' // this % marks ( this % imark )% method , color_fg = 'green' , style = 'bold_on' ),& colorize ( '; Des.: ' // this % marks ( this % imark )% description , color_fg = 'green_intense' ),& '; Argi.:' ,& this % argi elseif (. not . present ( description ) . and . present ( argi ) . and . this_image () == 1 ) then print '(a,\" \",a,*(g0,1x))' ,& colorize ( 'Meth.: ' // this % marks ( this % imark )% method , color_fg = 'green' , style = 'bold_on' ),& '; Argi.:' ,& this % argi elseif ( present ( description ) . and . . not . present ( argi ) . and . this_image () == 1 ) then print '(a,a)' ,& colorize ( 'Meth.: ' // this % marks ( this % imark )% method , color_fg = 'green' , style = 'bold_on' ),& colorize ( '; Des.: ' // this % marks ( this % imark )% description , color_fg = 'green_intense' ) elseif (. not . present ( description ) . and . . not . present ( argi ) . and . this_image () == 1 ) then print '(a)' , colorize ( 'Meth.: ' // this % marks ( this % imark )% method , color_fg = 'green' , style = 'bold_on' ) end if select case ( trim ( this % timer )) case ( 'wall' ) call this % marks_co ( this % imark )% time % timer_start () case ( 'date_and_time' ) call this % marks_co ( this % imark )% time % dtimer_start () case ( 'cpu' ) call this % marks_co ( this % imark )% time % ctimer_start () case ( 'omp' ) #if defined(USE_OMP) call this % marks_co ( this % imark )% time % ptimer_start () #else error stop 'Use -DUSE_OMP to enable OpenMP.' #endif case ( 'mpi' ) #if defined(USE_MPI) call this % marks_co ( this % imark )% time % mtimer_start () #else error stop 'Use -DUSE_MPI to enable MPI.' #endif end select end subroutine start_benchmark","tags":"","loc":"proc/start_benchmark~2.html"},{"title":"stop_benchmark – ForBenchmark","text":"private impure subroutine stop_benchmark(this, flops) Uses face proc~~stop_benchmark~2~~UsesGraph proc~stop_benchmark~2 forbenchmark_coarray::benchmark%stop_benchmark face face proc~stop_benchmark~2->face Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Stops the currently active benchmark, calculates performance metrics, and writes the results to the file and terminal. Type Bound benchmark Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Benchmark object procedure(Fun), optional :: flops Function to calculate Floating Point Operations Per Second (optional) Calls proc~~stop_benchmark~2~~CallsGraph proc~stop_benchmark~2 forbenchmark_coarray::benchmark%stop_benchmark colorize colorize proc~stop_benchmark~2->colorize ctimer_stop ctimer_stop proc~stop_benchmark~2->ctimer_stop dtimer_stop dtimer_stop proc~stop_benchmark~2->dtimer_stop mtimer_stop mtimer_stop proc~stop_benchmark~2->mtimer_stop otimer_stop otimer_stop proc~stop_benchmark~2->otimer_stop proc~write_benchmark~2 forbenchmark_coarray::benchmark%write_benchmark proc~stop_benchmark~2->proc~write_benchmark~2 timer_stop timer_stop proc~stop_benchmark~2->timer_stop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine stop_benchmark ( this , flops ) !! author: Seyed Ali Ghasemi !! Stops the currently active benchmark, calculates performance metrics, and writes the results to the file and terminal. !! use face interface impure function Fun ( argi , argr ) import rk , ik integer ( ik ), dimension (:), intent ( in ), optional :: argi real ( rk ), dimension (:), intent ( in ), optional :: argr real ( rk ) :: Fun end function Fun end interface procedure ( Fun ), optional :: flops !! Function to calculate Floating Point Operations Per Second (optional) class ( benchmark ), intent ( inout ) :: this !! Benchmark object real ( rk ) :: elapsed_time_average !! Average elapsed time for the benchmark in all images real ( rk ) :: elapsed_time_min !! Minimum elapsed time for the benchmark in all images real ( rk ) :: elapsed_time_max !! Maximum elapsed time for the benchmark in all images real ( rk ) :: flops_total !! Total floating-point operations per second in all images real ( rk ), dimension (:), allocatable :: elapsed_times !! Array of elapsed times in all images integer :: i select case ( trim ( this % timer )) case ( 'wall' ) call this % marks_co ( this % imark )% time % timer_stop ( message = ' Elapsed time :' , nloops = this % nloops ) this % marks_co ( this % imark )% elapsed_time = this % marks_co ( this % imark )% time % elapsed_time case ( 'date_and_time' ) call this % marks_co ( this % imark )% time % dtimer_stop ( message = ' Elapsed time :' , nloops = this % nloops ) this % marks_co ( this % imark )% elapsed_time = this % marks_co ( this % imark )% time % elapsed_dtime case ( 'cpu' ) call this % marks_co ( this % imark )% time % ctimer_stop ( message = ' Elapsed time :' , nloops = this % nloops ) this % marks_co ( this % imark )% elapsed_time = this % marks_co ( this % imark )% time % cpu_time case ( 'omp' ) #if defined(USE_OMP) call this % marks_co ( this % imark )% time % otimer_stop ( message = ' Elapsed time :' , nloops = this % nloops ) this % marks_co ( this % imark )% elapsed_time = this % marks_co ( this % imark )% time % omp_time #else error stop 'Use -DUSE_OMP to enable OpenMP.' #endif case ( 'mpi' ) #if defined(USE_MPI) call this % marks_co ( this % imark )% time % mtimer_stop ( message = ' Elapsed time :' , nloops = this % nloops ) this % marks_co ( this % imark )% elapsed_time = this % marks_co ( this % imark )% time % mpi_time #else error stop 'Use -DUSE_MPI to enable MPI.' #endif end select if ( present ( flops )) then if ( this % marks_co ( this % imark )% elapsed_time <= epsilon ( 0.0_rk )) error stop 'Elapsed time is too small.' this % marks_co ( this % imark )% flops = flops ( this % argi , this % argr ) / this % marks_co ( this % imark )% elapsed_time print '(a,f7.3,a)' , ' Performance  :' , this % marks_co ( this % imark )% flops , ' [GFLOPS/image]' else this % marks_co ( this % imark )% flops = 0.0_rk end if sync all if ( this_image () == 1 ) then allocate ( elapsed_times ( num_images ())) do i = 1 , num_images () elapsed_times ( i ) = this % marks_co ( this % imark )[ i ]% elapsed_time end do elapsed_time_max = maxval ( elapsed_times ) elapsed_time_min = minval ( elapsed_times ) elapsed_time_average = sum ( elapsed_times ) / num_images () if ( present ( flops )) flops_total = 0.0_rk do i = 1 , num_images () if ( present ( flops )) flops_total = flops_total + this % marks_co ( this % imark )[ i ]% flops end do end if call co_broadcast ( elapsed_time_average , 1 ) call co_broadcast ( elapsed_time_min , 1 ) call co_broadcast ( elapsed_time_max , 1 ) if ( present ( flops )) call co_broadcast ( flops_total , 1 ) this % marks ( this % imark )% elapsed_time_average = elapsed_time_average this % marks ( this % imark )% elapsed_time_min = elapsed_time_min this % marks ( this % imark )% elapsed_time_max = elapsed_time_max if ( this % marks ( 1 )% elapsed_time_max <= epsilon ( 0.0_rk )) error stop 'Maximum elapsed time for the reference benchmark is too small.' this % marks ( this % imark )% speedup_max_total = this % marks ( this % imark )% elapsed_time_max / this % marks ( 1 )% elapsed_time_max if ( this_image () == 1 ) then print '(a,f7.3,a)' , colorize ( ' Elapsed time (max)     :' , color_fg = 'blue' ),& this % marks ( this % imark )% elapsed_time_max , ' [s]' print '(a,f7.3,a)' , colorize ( ' Elapsed time (min)     :' , color_fg = 'blue' ),& this % marks ( this % imark )% elapsed_time_min , ' [s]' print '(a,f7.3,a)' , colorize ( ' Elapsed time (average) :' , color_fg = 'blue' ),& this % marks ( this % imark )% elapsed_time_average , ' [s]' print '(a,f7.3,a)' , colorize ( ' Speedup (max)          :' , color_fg = 'blue' ),& this % marks ( this % imark )% speedup_max_total , ' [-]' if ( present ( flops )) print '(a,f7.3,a)' , colorize ( ' Performance  (total)   :' , color_fg = 'cyan' ),& flops_total , ' [GFLOPS]' print '(a)' , '' end if if ( present ( flops )) then this % marks ( this % imark )% flops_total = flops_total else this % marks ( this % imark )% flops_total = 0.0_rk end if call this % write_benchmark () end subroutine stop_benchmark","tags":"","loc":"proc/stop_benchmark~2.html"},{"title":"write_benchmark – ForBenchmark","text":"private impure subroutine write_benchmark(this) Writes the benchmark data to a specified file, including method, speedup, elapsed time, flops, and other details. Type Bound benchmark Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Benchmark object Called by proc~~write_benchmark~2~~CalledByGraph proc~write_benchmark~2 forbenchmark_coarray::benchmark%write_benchmark proc~stop_benchmark~2 forbenchmark_coarray::benchmark%stop_benchmark proc~stop_benchmark~2->proc~write_benchmark~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine write_benchmark ( this ) !! author: Seyed Ali Ghasemi !! Writes the benchmark data to a specified file, including method, speedup, elapsed time, flops, and other details. !! class ( benchmark ), intent ( inout ) :: this !! Benchmark object integer :: nunit !! Unit number for file access character ( len = 53 ) :: fmt1 !! Format for write character ( len = 82 ) :: fmt2 !! Format for write logical :: exist !! Logical variable for file existence integer :: iostat !! I/O status integer :: lm lm = 20 - len_trim ( this % marks ( this % imark )% method ) write ( fmt1 , '(a,g0,a)' )& '(a,' , lm , 'x,3x,E20.14,3x,E20.14,3x,g8.0,3x,*(g8.0,3x))' inquire ( file = this % filename_image , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename_image ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename_image , access = 'append' ) write ( nunit , fmt1 ) & this % marks ( this % imark )% method ,& this % marks_co ( this % imark )% time % elapsed_time ,& this % marks_co ( this % imark )% flops ,& this % nloops ,& this % argi close ( nunit ) if ( this_image () == 1 ) then write ( fmt2 , '(a,g0,a)' )& '(a,' , lm , 'x,3x,F12.6,3x,E20.14,3x,E20.14,3x,E20.14,3x,E20.14,3x,g8.0,3x,*(g20.0,3x))' inquire ( file = this % filename , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename , access = 'append' ) write ( nunit , fmt2 ) & this % marks ( this % imark )% method ,& this % marks ( this % imark )% speedup_max_total ,& this % marks ( this % imark )% elapsed_time_max ,& this % marks ( this % imark )% elapsed_time_min ,& this % marks ( this % imark )% elapsed_time_average ,& this % marks ( this % imark )% flops_total ,& this % nloops ,& this % argi close ( nunit ) end if end subroutine write_benchmark","tags":"","loc":"proc/write_benchmark~2.html"},{"title":"finalize_mark – ForBenchmark","text":"private pure elemental subroutine finalize_mark(this) Finalizes the mark object by deallocating allocated memory for method and description. Type Bound mark Arguments Type Intent Optional Attributes Name class( mark ), intent(inout) :: this Mark object to be finalized Called by proc~~finalize_mark~2~~CalledByGraph proc~finalize_mark~2 forbenchmark_coarray::mark%finalize_mark proc~finalize~2 forbenchmark_coarray::benchmark%finalize proc~finalize~2->proc~finalize_mark~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure elemental subroutine finalize_mark ( this ) !! author: Seyed Ali Ghasemi !! Finalizes the mark object by deallocating allocated memory for method and description. !! class ( mark ), intent ( inout ) :: this !! Mark object to be finalized if ( allocated ( this % method )) deallocate ( this % method ) if ( allocated ( this % description )) deallocate ( this % description ) end subroutine finalize_mark","tags":"","loc":"proc/finalize_mark~2.html"},{"title":"finalize – ForBenchmark","text":"private impure elemental subroutine finalize(this) Finalizes the benchmark object by deallocating memory and performs necessary cleanup. Type Bound benchmark Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Benchmark object to be finalized Calls proc~~finalize~2~~CallsGraph proc~finalize~2 forbenchmark_coarray::benchmark%finalize proc~finalize_mark~2 forbenchmark_coarray::mark%finalize_mark proc~finalize~2->proc~finalize_mark~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental impure subroutine finalize ( this ) !! author: Seyed Ali Ghasemi !! Finalizes the benchmark object by deallocating memory and performs necessary cleanup. !! class ( benchmark ), intent ( inout ) :: this !! Benchmark object to be finalized integer :: nunit !! Unit number for file access logical :: exist !! Logical variable for file existence integer :: iostat !! I/O status inquire ( file = this % filename_image , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename_image ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename_image , access = 'append' ) write ( nunit , '(a)' ) 'end of benchmark' close ( nunit ) if ( this_image () == 1 ) then inquire ( file = this % filename , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename , access = 'append' ) write ( nunit , '(a)' ) 'end of benchmark' close ( nunit ) end if if ( allocated ( this % marks_co )) deallocate ( this % marks_co ) call this % marks % finalize_mark () if ( allocated ( this % marks )) deallocate ( this % marks ) if ( allocated ( this % filename_image )) deallocate ( this % filename_image ) if ( allocated ( this % argi )) deallocate ( this % argi ) if ( allocated ( this % argr )) deallocate ( this % argr ) if ( this_image () == 1 ) print '(a)' , 'end of benchmark' end subroutine finalize","tags":"","loc":"proc/finalize~2.html"},{"title":"cmp_gflops – ForBenchmark","text":"function cmp_gflops(argi, argr) result(gflops) Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in), optional, dimension(:) :: argi real(kind=rk), intent(in), optional, dimension(:) :: argr Return Value real(kind=rk) Source Code function cmp_gflops ( argi , argr ) result ( gflops ) integer ( ik ), dimension (:), intent ( in ), optional :: argi real ( rk ), dimension (:), intent ( in ), optional :: argr real ( rk ) :: gflops gflops = real ( argi ( 1 ), rk ) * real ( argi ( 2 ), rk ) * real ( argi ( 3 ), rk ) * 1.0e-9_rk end function cmp_gflops","tags":"","loc":"proc/cmp_gflops.html"},{"title":"forbenchmark – ForBenchmark","text":"This module is used to switch between the default and coarray versions of the benchmark Uses forbenchmark_coarray forbenchmark_default module~~forbenchmark~~UsesGraph module~forbenchmark forbenchmark module~forbenchmark_coarray forbenchmark_coarray module~forbenchmark->module~forbenchmark_coarray module~forbenchmark_default forbenchmark_default module~forbenchmark->module~forbenchmark_default fortime fortime module~forbenchmark_coarray->fortime kinds kinds module~forbenchmark_coarray->kinds module~forbenchmark_default->fortime module~forbenchmark_default->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forbenchmark~~UsedByGraph module~forbenchmark forbenchmark program~demo demo program~demo->module~forbenchmark Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"module/forbenchmark.html"},{"title":"forbenchmark_default – ForBenchmark","text":"A Fortran module for benchmarking and performance evaluation for non-coarray codes. Uses kinds fortime module~~forbenchmark_default~~UsesGraph module~forbenchmark_default forbenchmark_default fortime fortime module~forbenchmark_default->fortime kinds kinds module~forbenchmark_default->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forbenchmark_default~~UsedByGraph module~forbenchmark_default forbenchmark_default module~forbenchmark forbenchmark module~forbenchmark->module~forbenchmark_default program~demo demo program~demo->module~forbenchmark Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, private :: mark Derived type for each method being benchmarked. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: method Name of the method being benchmarked character(len=:), public, allocatable :: description Description of the method being benchmarked type(timer), public :: time Timer object to measure elapsed time real(kind=rk), public :: elapsed_time Elapsed time for the benchmark real(kind=rk), public :: speedup Speedup relative to a reference benchmark real(kind=rk), public :: flops Floating-point operations per second Type-Bound Procedures procedure, private :: finalize_mark ../../ Finalize procedure for mark type type, public :: benchmark Derived type for benchmarking and performance evaluation. Components Type Visibility Attributes Name Initial type( mark ), public, dimension(:), allocatable :: marks Array of marks to store benchmark data character(len=:), public, allocatable :: filename Filename for storing benchmark data integer, public :: nloops Number of loops for each benchmark integer(kind=ik), public, dimension(:), allocatable :: argi Integer arguments for benchmarks real(kind=rk), public, dimension(:), allocatable :: argr Real arguments for benchmarks character(len=:), public, allocatable :: timer Timer object for measuring time integer, public :: imark Index of current benchmark mark Type-Bound Procedures procedure, public :: init ../../ Initialize the benchmark object procedure, public :: start_benchmark ../../ Start a benchmark procedure, public :: stop_benchmark ../../ Stop a benchmark procedure, private :: write_benchmark ../../ Write benchmark data to file procedure, public :: finalize ../../ Finalize the benchmark object Functions private impure function current_date_and_time () result(datetime) Author Seyed Ali Ghasemi License BSD 3-Clause License Retrieves the current date and time and returns it as a string\nIt utilizes the intrinsic date_and_time function to obtain system time information.\nA string containing the current date and time in the format \"YYYY.MM.DD - HH:MM:SS\". Arguments None Return Value character(len=21) Character containing the current date and time Subroutines private impure elemental subroutine init (this, nmarks, title, filename, nloops, timer) Author Seyed Ali Ghasemi License BSD 3-Clause License Initialize the benchmark object. Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Benchmark object integer, intent(in) :: nmarks Number of methods to be benchmarked character(len=*), intent(in), optional :: title Title of the benchmark character(len=*), intent(in), optional :: filename Filename for storing benchmark data integer, intent(in), optional :: nloops Number of loops for each benchmark (default: 10) character(len=*), intent(in), optional :: timer Timer object for measuring time (default: wall). The timer options available are 'wall', 'date_and_time', 'cpu', 'omp', and 'mpi'. private impure subroutine start_benchmark (this, imark, method, description, argi, argr) Author Seyed Ali Ghasemi License BSD 3-Clause License Start a specific benchmark Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Benchmark object integer, intent(in) :: imark Index of the current method character(len=*), intent(in) :: method Name of the method being benchmarked character(len=*), intent(in), optional :: description Description of the method being benchmarked (optional) integer(kind=ik), intent(in), optional, dimension(:) :: argi Integer arguments for the benchmark (optional) real(kind=rk), intent(in), optional, dimension(:) :: argr Real arguments for the benchmark (optional) private impure subroutine stop_benchmark (this, flops) Author Seyed Ali Ghasemi License BSD 3-Clause License Stops the currently active benchmark, calculates performance metrics, and writes the results to the file and terminal. Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Benchmark object procedure(Fun), optional :: flops Function to calculate Floating Point Operations Per Second (optional) private impure subroutine write_benchmark (this) Author Seyed Ali Ghasemi License BSD 3-Clause License Writes the benchmark data to a specified file, including method, speedup, elapsed time, flops, and other details. Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Benchmark object private pure elemental subroutine finalize_mark (this) Author Seyed Ali Ghasemi License BSD 3-Clause License Finalizes the mark object by deallocating allocated memory for method and description. Arguments Type Intent Optional Attributes Name class( mark ), intent(inout) :: this Mark object to be finalized private impure elemental subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause License Finalizes the benchmark object by deallocating memory and performs necessary cleanup. Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Benchmark object to be finalized","tags":"","loc":"module/forbenchmark_default.html"},{"title":"forbenchmark_coarray – ForBenchmark","text":"A Fortran module for benchmarking and performance evaluation for coarray codes. Uses kinds fortime module~~forbenchmark_coarray~~UsesGraph module~forbenchmark_coarray forbenchmark_coarray fortime fortime module~forbenchmark_coarray->fortime kinds kinds module~forbenchmark_coarray->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forbenchmark_coarray~~UsedByGraph module~forbenchmark_coarray forbenchmark_coarray module~forbenchmark forbenchmark module~forbenchmark->module~forbenchmark_coarray program~demo demo program~demo->module~forbenchmark Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, private :: mark_co Derived type for each method being benchmarked in each image. Components Type Visibility Attributes Name Initial type(timer), public :: time Timer object to measure elapsed time in each image real(kind=rk), public :: elapsed_time Elapsed time for the benchmark in each image real(kind=rk), public :: flops Floating-point operations per second in each image type, private :: mark Derived type for each method being benchmarked in all images. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: method Name of the method being benchmarked character(len=:), public, allocatable :: description Description of the method being benchmarked real(kind=rk), public :: elapsed_time_min Minimum elapsed time for the benchmark in all images real(kind=rk), public :: elapsed_time_average Average elapsed time for the benchmark in all images real(kind=rk), public :: elapsed_time_max Maximum elapsed time for the benchmark in all images real(kind=rk), public :: flops_total Total floating-point operations per second in all images real(kind=rk), public :: speedup_max_total Maximum speedup in all images compared to the reference benchmark Type-Bound Procedures procedure, private :: finalize_mark ../../ Finalize procedure for mark type type, public :: benchmark Derived type for benchmarking and performance evaluation. Components Type Visibility Attributes Name Initial type( mark_co ), public, dimension(:), allocatable :: marks_co [:] Array of mark_co type for each method being benchmarked in each image type( mark ), public, dimension(:), allocatable :: marks Array of mark type for each method being benchmarked in all images character(len=:), public, allocatable :: filename Filename for storing the benchmark data in all images character(len=:), public, allocatable :: filename_image Filename for storing the benchmark data in each image integer, public :: nloops Number of loops for each benchmark integer(kind=ik), public, dimension(:), allocatable :: argi Integer arguments for benchmarks real(kind=rk), public, dimension(:), allocatable :: argr Real arguments for benchmarks character(len=:), public, allocatable :: timer Timer object for measuring time integer, public :: imark Index of the current benchmark Type-Bound Procedures procedure, public :: init ../../ Initialization the benchmark object procedure, public :: start_benchmark ../../ Start a benchmark procedure, public :: stop_benchmark ../../ Stop a benchmark procedure, private :: write_benchmark ../../ Write benchmark data to file procedure, public :: finalize ../../ Finalize the benchmark object Functions private impure function current_date_and_time () result(datetime) Author Seyed Ali Ghasemi License BSD 3-Clause License Retrieves the current date and time and returns it as a string\nIt utilizes the intrinsic date_and_time function to obtain system time information.\nA string containing the current date and time in the format \"YYYY.MM.DD - HH:MM:SS\". Arguments None Return Value character(len=21) Character containing the current date and time Subroutines private impure elemental subroutine init (this, nmarks, title, filename, nloops, timer) Author Seyed Ali Ghasemi License BSD 3-Clause License Initialize the benchmark object. Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Benchmark object integer, intent(in) :: nmarks Number of methods being benchmarked character(len=*), intent(in), optional :: title Title of the benchmark character(len=*), intent(in), optional :: filename Filename for storing the benchmark data integer, intent(in), optional :: nloops Number of loops for each benchmark (default: 10) character(len=*), intent(in), optional :: timer Timer object for measuring time (default: wall) private impure subroutine start_benchmark (this, imark, method, description, argi, argr) Author Seyed Ali Ghasemi License BSD 3-Clause License Start a specific benchmark. Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Benchmark object integer, intent(in) :: imark Index of the current method character(len=*), intent(in) :: method Name of the method being benchmarked character(len=*), intent(in), optional :: description Description of the method being benchmarked (optional) integer(kind=ik), intent(in), optional, dimension(:) :: argi Integer arguments for benchmarks (optional) real(kind=rk), intent(in), optional, dimension(:) :: argr Real arguments for benchmarks (optional) private impure subroutine stop_benchmark (this, flops) Author Seyed Ali Ghasemi License BSD 3-Clause License Stops the currently active benchmark, calculates performance metrics, and writes the results to the file and terminal. Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Benchmark object procedure(Fun), optional :: flops Function to calculate Floating Point Operations Per Second (optional) private impure subroutine write_benchmark (this) Author Seyed Ali Ghasemi License BSD 3-Clause License Writes the benchmark data to a specified file, including method, speedup, elapsed time, flops, and other details. Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Benchmark object private pure elemental subroutine finalize_mark (this) Author Seyed Ali Ghasemi License BSD 3-Clause License Finalizes the mark object by deallocating allocated memory for method and description. Arguments Type Intent Optional Attributes Name class( mark ), intent(inout) :: this Mark object to be finalized private impure elemental subroutine finalize (this) Author Seyed Ali Ghasemi License BSD 3-Clause License Finalizes the benchmark object by deallocating memory and performs necessary cleanup. Arguments Type Intent Optional Attributes Name class( benchmark ), intent(inout) :: this Benchmark object to be finalized","tags":"","loc":"module/forbenchmark_coarray.html"},{"title":"demo – ForBenchmark","text":"Uses forbenchmark kinds program~~demo~~UsesGraph program~demo demo kinds kinds program~demo->kinds module~forbenchmark forbenchmark program~demo->module~forbenchmark module~forbenchmark_coarray forbenchmark_coarray module~forbenchmark->module~forbenchmark_coarray module~forbenchmark_default forbenchmark_default module~forbenchmark->module~forbenchmark_default module~forbenchmark_coarray->kinds fortime fortime module~forbenchmark_coarray->fortime module~forbenchmark_default->kinds module~forbenchmark_default->fortime Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~demo~~CallsGraph program~demo demo proc~finalize forbenchmark_default::benchmark%finalize program~demo->proc~finalize proc~init forbenchmark_default::benchmark%init program~demo->proc~init proc~start_benchmark forbenchmark_default::benchmark%start_benchmark program~demo->proc~start_benchmark proc~stop_benchmark forbenchmark_default::benchmark%stop_benchmark program~demo->proc~stop_benchmark proc~finalize_mark forbenchmark_default::mark%finalize_mark proc~finalize->proc~finalize_mark proc~current_date_and_time forbenchmark_default::current_date_and_time proc~init->proc~current_date_and_time colorize colorize proc~start_benchmark->colorize ctimer_start ctimer_start proc~start_benchmark->ctimer_start dtimer_start dtimer_start proc~start_benchmark->dtimer_start mtimer_start mtimer_start proc~start_benchmark->mtimer_start otimer_start otimer_start proc~start_benchmark->otimer_start timer_start timer_start proc~start_benchmark->timer_start ctimer_stop ctimer_stop proc~stop_benchmark->ctimer_stop dtimer_stop dtimer_stop proc~stop_benchmark->dtimer_stop mtimer_stop mtimer_stop proc~stop_benchmark->mtimer_stop otimer_stop otimer_stop proc~stop_benchmark->otimer_stop proc~write_benchmark forbenchmark_default::benchmark%write_benchmark proc~stop_benchmark->proc~write_benchmark timer_stop timer_stop proc~stop_benchmark->timer_stop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( benchmark ) :: bench real(kind=rk), dimension(:,:), allocatable :: A real(kind=rk), dimension(:,:), allocatable :: B real(kind=rk), dimension(:,:), allocatable :: C integer(kind=ik) :: p integer(kind=ik) :: nl integer(kind=ik) :: i integer(kind=ik) :: j integer(kind=ik) :: k Functions function cmp_gflops (argi, argr) result(gflops) Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in), optional, dimension(:) :: argi real(kind=rk), intent(in), optional, dimension(:) :: argr Return Value real(kind=rk) Source Code program demo use kinds , only : rk , ik ! use -DREAL32 or -DREAL64 to switch between real32 and real64, default is real64 ! use -DINT32 or -DINT64 to switch between int32 and int64, default is int32 use forbenchmark , only : benchmark ! forbenchmark module implicit none ! benchmark object type ( benchmark ) :: bench ! define your variables here real ( rk ), dimension (:,:), allocatable :: A , B , C integer ( ik ) :: p integer ( ik ) :: nl , i , j , k ! initialize the benchmark ! nmarks: number of methods to benchmark ! title: optional ! filename: optional. make sure directory exists ! nloops: optional. number of loops for each benchmark. default is 10. ! timer: optional. default is 'wall'. other options are 'cpu', 'omp'. 'mpi', 'date_and_time' call bench % init ( nmarks = 2 , title = 'Demo Benchmark' , filename = 'results/demo' , nloops = 2 , timer = 'wall' ) ! start the benchmark do p = 600_ik , 900_ik , 100_ik ! loop over problem size !=============================================================================== ! allocate and initialize your variables here if ( allocated ( A )) deallocate ( A ) if ( allocated ( B )) deallocate ( B ) if ( allocated ( C )) deallocate ( C ) allocate ( A ( p , p )) allocate ( B ( p , p )) allocate ( C ( p , p ), source = 0.0_rk ) call random_number ( A ) call random_number ( B ) !=============================================================================== !=============================================================================== ! start benchmark for method 1 ! imark is an integer to identify the method, 1 is for reference method ! method is a string to identify the method ! description is optional ! argi is an optional integer array of arguments to write in the output file and to compute gflops ! the first element in argi is used for x-axis in the plot ! argr is an optional real array of arguments to compute gflops ! loop over nloops call bench % start_benchmark ( imark = 1 , method = 'm1' , description = 'intrinsic, C = matmul(A,B)' , argi = [ p , p , p ]) ! loop over nloops do nl = 1 , bench % nloops ! call your function or subroutine or ... ! here is used intrinsic matmul C = matmul ( A , B ) end do ! stop benchmark for method 1 ! flops is an optional function to compute flops call bench % stop_benchmark ( flops = cmp_gflops ) !=============================================================================== !=============================================================================== ! start benchmark for method 2, same as above. call bench % start_benchmark ( 2 , 'm2' , 'my_matmul, C = matmul(A,B)' , [ p , p , p ]) do nl = 1 , bench % nloops ! call your function or subroutine or ... ! here is used another matmul C = 0.0_rk do i = 1 , p do j = 1 , p do k = 1 , p C ( i , j ) = C ( i , j ) + A ( i , k ) * B ( k , j ) end do end do end do end do call bench % stop_benchmark ( cmp_gflops ) !=============================================================================== ! you can add more methods ... end do ! end loop over p ! finalize the benchmark call bench % finalize () ! you can use a python script to plot and export the results as follows: ! python results/export.py demo.data ! for coarray benchmarks, utilize: ! python results/export_co.py demo_co.data ! python results/export_im.py demo_im1.data ! python results/export_im.py demo_im2.data ! ... contains !=============================================================================== ! define an optional function to compute gflops function cmp_gflops ( argi , argr ) result ( gflops ) integer ( ik ), dimension (:), intent ( in ), optional :: argi real ( rk ), dimension (:), intent ( in ), optional :: argr real ( rk ) :: gflops gflops = real ( argi ( 1 ), rk ) * real ( argi ( 2 ), rk ) * real ( argi ( 3 ), rk ) * 1.0e-9_rk end function cmp_gflops !=============================================================================== end program demo","tags":"","loc":"program/demo.html"},{"title":"forbenchmark.f90 – ForBenchmark","text":"This file depends on sourcefile~~forbenchmark.f90~~EfferentGraph sourcefile~forbenchmark.f90 forbenchmark.f90 sourcefile~forbenchmark_coarray.f90 forbenchmark_coarray.f90 sourcefile~forbenchmark.f90->sourcefile~forbenchmark_coarray.f90 sourcefile~forbenchmark_default.f90 forbenchmark_default.f90 sourcefile~forbenchmark.f90->sourcefile~forbenchmark_default.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~forbenchmark.f90~~AfferentGraph sourcefile~forbenchmark.f90 forbenchmark.f90 sourcefile~demo.f90 demo.f90 sourcefile~demo.f90->sourcefile~forbenchmark.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module forbenchmark !! author: Seyed Ali Ghasemi !! license: BSD 3-Clause License !! This module is used to switch between the default and coarray versions of the benchmark !! #if defined(USE_COARRAY) use forbenchmark_coarray #else use forbenchmark_default #endif public benchmark end module forbenchmark","tags":"","loc":"sourcefile/forbenchmark.f90.html"},{"title":"forbenchmark_default.f90 – ForBenchmark","text":"Files dependent on this one sourcefile~~forbenchmark_default.f90~~AfferentGraph sourcefile~forbenchmark_default.f90 forbenchmark_default.f90 sourcefile~forbenchmark.f90 forbenchmark.f90 sourcefile~forbenchmark.f90->sourcefile~forbenchmark_default.f90 sourcefile~demo.f90 demo.f90 sourcefile~demo.f90->sourcefile~forbenchmark.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module forbenchmark_default !! author: Seyed Ali Ghasemi !! license: BSD 3-Clause License !! A Fortran module for benchmarking and performance evaluation for non-coarray codes. !! use kinds use fortime , only : timer implicit none private public benchmark !=============================================================================== type :: mark !! author: Seyed Ali Ghasemi !! Derived type for each method being benchmarked. !! character (:), allocatable :: method !! Name of the method being benchmarked character (:), allocatable :: description !! Description of the method being benchmarked type ( timer ) :: time !! Timer object to measure elapsed time real ( rk ) :: elapsed_time !! Elapsed time for the benchmark real ( rk ) :: speedup !! Speedup relative to a reference benchmark real ( rk ) :: flops !! Floating-point operations per second contains procedure , private :: finalize_mark !! Finalize procedure for mark type end type mark !=============================================================================== !=============================================================================== type :: benchmark !! author: Seyed Ali Ghasemi !! Derived type for benchmarking and performance evaluation. !! type ( mark ), dimension (:), allocatable :: marks !! Array of marks to store benchmark data character (:), allocatable :: filename !! Filename for storing benchmark data integer :: nloops !! Number of loops for each benchmark integer ( ik ), dimension (:), allocatable :: argi !! Integer arguments for benchmarks real ( rk ), dimension (:), allocatable :: argr !! Real arguments for benchmarks character (:), allocatable :: timer !! Timer object for measuring time integer :: imark !! Index of current benchmark mark contains procedure :: init !! Initialize the benchmark object procedure :: start_benchmark !! Start a benchmark procedure :: stop_benchmark !! Stop a benchmark procedure , private :: write_benchmark !! Write benchmark data to file procedure :: finalize !! Finalize the benchmark object end type benchmark !=============================================================================== contains !=============================================================================== elemental impure subroutine init ( this , nmarks , title , filename , nloops , timer ) !! author: Seyed Ali Ghasemi !! Initialize the benchmark object. !! use , intrinsic :: iso_fortran_env , only : compiler_version , compiler_options class ( benchmark ), intent ( inout ) :: this !! Benchmark object integer , intent ( in ) :: nmarks !! Number of methods to be benchmarked character ( * ), intent ( in ), optional :: title !! Title of the benchmark character ( * ), intent ( in ), optional :: filename !! Filename for storing benchmark data integer , intent ( in ), optional :: nloops !! Number of loops for each benchmark (default: 10) character ( * ), intent ( in ), optional :: timer !! Timer object for measuring time (default: wall). The timer options available are 'wall', 'date_and_time', 'cpu', 'omp', and 'mpi'. integer :: nunit !! Unit number for file access integer :: iostat !! I/O status integer :: which_compiler !! Logical variables for compiler detection character (:), allocatable :: compiler !! Compiler name if ( nmarks <= 0 ) error stop 'nmarks must be greater than zero.' allocate ( this % marks ( nmarks )) compiler = '' which_compiler = index ( compiler_version (), 'Intel(R) Fortran Compiler' ) if ( which_compiler /= 0 ) compiler = '_ifx' which_compiler = index ( compiler_version (), 'Intel(R) Fortran Intel(R)' ) if ( which_compiler /= 0 ) compiler = '_ifort' which_compiler = index ( compiler_version (), 'GCC' ) if ( which_compiler /= 0 ) compiler = '_gfortran' which_compiler = index ( compiler_version (), 'nvfortran' ) if ( which_compiler /= 0 ) compiler = '_nvfortran' if ( present ( filename )) then this % filename = trim ( filename // compiler // '.data' ) else this % filename = 'benchmark' // compiler // '.data' endif if ( present ( nloops )) then if ( nloops <= 0 ) error stop 'nloops must be greater than zero.' this % nloops = nloops else this % nloops = 10 end if if ( present ( timer )) then select case ( trim ( timer )) case ( 'wall' ) this % timer = 'wall' case ( 'date_and_time' ) this % timer = 'date_and_time' case ( 'cpu' ) this % timer = 'cpu' case ( 'omp' ) #if defined(USE_OMP) this % timer = 'omp' #else error stop 'Use -DUSE_OMP to enable OpenMP.' #endif case ( 'mpi' ) #if defined(USE_MPI) this % timer = 'mpi' #else error stop 'Use -DUSE_MPI to enable MPI.' #endif case default error stop 'timer is not valid. Valid options are: wall, date_and_time, cpu, omp, mpi.' end select else this % timer = 'wall' end if inquire ( file = this % filename , iostat = iostat ) if ( iostat /= 0 ) then error stop 'file ' // trim ( this % filename ) // ' cannot be accessed.' end if open ( newunit = nunit , file = this % filename ) write ( nunit , '(a)' ) '-----------------------------------------------------' write ( nunit , '(a)' ) 'ForBenchmark - https://github.com/gha3mi/forbenchmark' write ( nunit , '(a)' ) '-----------------------------------------------------' write ( nunit , '(a)' ) '' if ( present ( title )) then write ( nunit , '(a)' ) trim ( title ) else write ( nunit , '(a)' ) 'ForBenchmark' endif write ( nunit , '(a)' ) current_date_and_time () write ( nunit , '(a)' ) '' write ( nunit , '(a,a)' ) 'compiler_version: ' , compiler_version () write ( nunit , '(a,a)' ) 'compiler_options: ' , compiler_options () write ( nunit , '(a)' ) '' write ( nunit , '(a)' ) '' write ( nunit , '(a)' ) & & '       METHOD        |& &   SPEEDUP    |& &         TIME         |& &        GFLOPS        |& &  NLOOPS  |& &   ARGI  ' close ( nunit ) end subroutine init !=============================================================================== !=============================================================================== impure subroutine start_benchmark ( this , imark , method , description , argi , argr ) !! author: Seyed Ali Ghasemi !! Start a specific benchmark !! use face class ( benchmark ), intent ( inout ) :: this !! Benchmark object integer , intent ( in ) :: imark !! Index of the current method character ( * ), intent ( in ) :: method !! Name of the method being benchmarked integer ( ik ), dimension (:), intent ( in ), optional :: argi !! Integer arguments for the benchmark (optional) real ( rk ), dimension (:), intent ( in ), optional :: argr !! Real arguments for the benchmark (optional) character ( * ), intent ( in ), optional :: description !! Description of the method being benchmarked (optional) if ( imark <= 0 . or . imark > size ( this % marks )) error stop 'imark is out of range.' this % imark = imark this % marks ( this % imark )% description = description this % marks ( this % imark )% method = method if ( present ( argi )) then this % argi = argi else if (. not . allocated ( this % argi )) allocate ( this % argi ( 0 )) endif if ( present ( argr )) then this % argr = argr else if (. not . allocated ( this % argr )) allocate ( this % argr ( 0 )) endif if ( present ( description ) . and . present ( argi )) then print '(a,a,\" \",a,*(g0,1x))' ,& colorize ( 'Meth.: ' // this % marks ( this % imark )% method , color_fg = 'green' , style = 'bold_on' ),& colorize ( '; Des.: ' // this % marks ( this % imark )% description , color_fg = 'green_intense' ),& '; Argi.:' ,& this % argi elseif ( present ( description ) . and . . not . present ( argi )) then print '(a,a,\" \",a)' ,& colorize ( 'Meth.: ' // this % marks ( this % imark )% method , color_fg = 'green' , style = 'bold_on' ),& colorize ( '; Des.: ' // this % marks ( this % imark )% description , color_fg = 'green_intense' ) elseif (. not . present ( description ) . and . present ( argi )) then print '(a,a,*(g0,1x))' ,& colorize ( 'Meth.: ' // this % marks ( this % imark )% method , color_fg = 'green' , style = 'bold_on' ),& '; Argi.:' ,& this % argi else print '(a)' , colorize ( 'Meth.: ' // this % marks ( this % imark )% method , color_fg = 'green' , style = 'bold_on' ) end if select case ( trim ( this % timer )) case ( 'wall' ) call this % marks ( this % imark )% time % timer_start () case ( 'date_and_time' ) call this % marks ( this % imark )% time % dtimer_start () case ( 'cpu' ) call this % marks ( this % imark )% time % ctimer_start () case ( 'omp' ) #if defined(USE_OMP) call this % marks ( this % imark )% time % otimer_start () #else error stop 'Use -DUSE_OMP to enable OpenMP.' #endif case ( 'mpi' ) #if defined(USE_MPI) call this % marks ( this % imark )% time % mtimer_start () #else error stop 'Use -DUSE_MPI to enable MPI.' #endif end select end subroutine start_benchmark !=============================================================================== !=============================================================================== impure subroutine stop_benchmark ( this , flops ) !! author: Seyed Ali Ghasemi !! Stops the currently active benchmark, calculates performance metrics, and writes the results to the file and terminal. !! interface impure function Fun ( argi , argr ) import rk , ik integer ( ik ), dimension (:), intent ( in ), optional :: argi real ( rk ), dimension (:), intent ( in ), optional :: argr real ( rk ) :: Fun end function Fun end interface procedure ( Fun ), optional :: flops !! Function to calculate Floating Point Operations Per Second (optional) class ( benchmark ), intent ( inout ) :: this !! Benchmark object select case ( trim ( this % timer )) case ( 'wall' ) call this % marks ( this % imark )% time % timer_stop ( message = ' Elapsed time :' , nloops = this % nloops ) this % marks ( this % imark )% elapsed_time = this % marks ( this % imark )% time % elapsed_time case ( 'date_and_time' ) call this % marks ( this % imark )% time % dtimer_stop ( message = ' Elapsed time :' , nloops = this % nloops ) this % marks ( this % imark )% elapsed_time = this % marks ( this % imark )% time % elapsed_dtime case ( 'cpu' ) call this % marks ( this % imark )% time % ctimer_stop ( message = ' Elapsed time :' , nloops = this % nloops ) this % marks ( this % imark )% elapsed_time = this % marks ( this % imark )% time % cpu_time case ( 'omp' ) #if defined(USE_OMP) call this % marks ( this % imark )% time % otimer_stop ( message = ' Elapsed time :' , nloops = this % nloops ) this % marks ( this % imark )% elapsed_time = this % marks ( this % imark )% time % omp_time #else error stop 'Use -DUSE_OMP to enable OpenMP.' #endif case ( 'mpi' ) #if defined(USE_MPI) call this % marks ( this % imark )% time % mtimer_stop ( message = ' Elapsed time :' , nloops = this % nloops ) this % marks ( this % imark )% elapsed_time = this % marks ( this % imark )% time % mpi_time #else error stop 'Use -DUSE_MPI to enable MPI.' #endif end select if ( this % marks ( this % imark )% elapsed_time <= epsilon ( 0.0_rk )) error stop 'Elapsed time is too small' this % marks ( this % imark )% speedup = this % marks ( 1 )% elapsed_time / this % marks ( this % imark )% elapsed_time if ( present ( flops )) then print '(a,f7.3,a)' , ' Speedup      :' , this % marks ( this % imark )% speedup , ' [-]' this % marks ( this % imark )% flops = flops ( this % argi , this % argr ) / this % marks ( this % imark )% elapsed_time print '(a,f7.3,a)' , ' Performance  :' , this % marks ( this % imark )% flops , ' [GFLOPS]' else this % marks ( this % imark )% flops = 0.0_rk endif print '(a)' , '' call this % write_benchmark () end subroutine stop_benchmark !=============================================================================== !=============================================================================== impure subroutine write_benchmark ( this ) !! author: Seyed Ali Ghasemi !! Writes the benchmark data to a specified file, including method, speedup, elapsed time, flops, and other details. !! class ( benchmark ), intent ( inout ) :: this !! Benchmark object integer :: nunit !! Unit number for file access character ( len = 65 ) :: fmt !! Format for write logical :: exist !! Logical variable for file existence integer :: iostat !! I/O status integer :: lm inquire ( file = this % filename , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename , access = 'append' ) lm = 20 - len_trim ( this % marks ( this % imark )% method ) write ( fmt , '(a,g0,a)' ) '(a,' , lm , 'x,3x,F12.6,3x,E20.14,3x,E20.14,3x,g8.0,3x,*(g20.0,3x))' write ( nunit , fmt ) & this % marks ( this % imark )% method ,& this % marks ( this % imark )% speedup ,& this % marks ( this % imark )% elapsed_time ,& this % marks ( this % imark )% flops ,& this % nloops ,& this % argi close ( nunit ) end subroutine write_benchmark !=============================================================================== !=============================================================================== elemental pure subroutine finalize_mark ( this ) !! author: Seyed Ali Ghasemi !! Finalizes the mark object by deallocating allocated memory for method and description. !! class ( mark ), intent ( inout ) :: this !! Mark object to be finalized if ( allocated ( this % method )) deallocate ( this % method ) if ( allocated ( this % description )) deallocate ( this % description ) end subroutine finalize_mark !=============================================================================== !=============================================================================== elemental impure subroutine finalize ( this ) !! author: Seyed Ali Ghasemi !! Finalizes the benchmark object by deallocating memory and performs necessary cleanup. !! class ( benchmark ), intent ( inout ) :: this !! Benchmark object to be finalized integer :: nunit !! Unit number for file access logical :: exist !! Logical variable for file existence integer :: iostat !! I/O status inquire ( file = this % filename , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename , access = 'append' ) write ( nunit , '(a)' ) 'end of benchmark' close ( nunit ) call this % marks (:)% finalize_mark () if ( allocated ( this % filename )) deallocate ( this % filename ) if ( allocated ( this % argi )) deallocate ( this % argi ) if ( allocated ( this % argr )) deallocate ( this % argr ) print '(a)' , 'end of benchmark' end subroutine finalize !=============================================================================== !=============================================================================== impure function current_date_and_time () result ( datetime ) !! author: Seyed Ali Ghasemi !! Retrieves the current date and time and returns it as a string !! It utilizes the intrinsic `date_and_time` function to obtain system time information. !! A string containing the current date and time in the format \"YYYY.MM.DD - HH:MM:SS\". !! character ( 21 ) :: datetime !! Character containing the current date and time character ( 10 ) :: date !! Character containing the current date character ( 8 ) :: time !! Character containing the current time integer :: values ( 8 ) !! Array containing the current date and time values character ( 4 ) :: year !! Current year character ( 2 ) :: month !! Current month character ( 2 ) :: day !! Current day character ( 2 ) :: hour !! Current hour character ( 2 ) :: minute !! Current minute character ( 2 ) :: second !! Current second call date_and_time ( values = values ) write ( year , '(i4)' ) values ( 1 ) write ( month , '(i2)' ) values ( 2 ) write ( day , '(i2)' ) values ( 3 ) write ( hour , '(i2)' ) values ( 5 ) write ( minute , '(i2)' ) values ( 6 ) write ( second , '(i2)' ) values ( 7 ) date = year // '.' // month // '.' // day time = hour // ':' // minute // ':' // second datetime = date // ' - ' // time end function current_date_and_time !=============================================================================== end module forbenchmark_default","tags":"","loc":"sourcefile/forbenchmark_default.f90.html"},{"title":"forbenchmark_coarray.f90 – ForBenchmark","text":"Files dependent on this one sourcefile~~forbenchmark_coarray.f90~~AfferentGraph sourcefile~forbenchmark_coarray.f90 forbenchmark_coarray.f90 sourcefile~forbenchmark.f90 forbenchmark.f90 sourcefile~forbenchmark.f90->sourcefile~forbenchmark_coarray.f90 sourcefile~demo.f90 demo.f90 sourcefile~demo.f90->sourcefile~forbenchmark.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module forbenchmark_coarray !! author: Seyed Ali Ghasemi !! license: BSD 3-Clause License !! A Fortran module for benchmarking and performance evaluation for coarray codes. !! #if defined(USE_COARRAY) use kinds use fortime , only : timer implicit none private public benchmark !=============================================================================== type :: mark_co !! author: Seyed Ali Ghasemi !! Derived type for each method being benchmarked in each image. !! type ( timer ) :: time !! Timer object to measure elapsed time in each image real ( rk ) :: elapsed_time !! Elapsed time for the benchmark in each image real ( rk ) :: flops !! Floating-point operations per second in each image end type mark_co !=============================================================================== !=============================================================================== type :: mark !! author: Seyed Ali Ghasemi !! Derived type for each method being benchmarked in all images. !! character (:), allocatable :: method !! Name of the method being benchmarked character (:), allocatable :: description !! Description of the method being benchmarked real ( rk ) :: elapsed_time_min !! Minimum elapsed time for the benchmark in all images real ( rk ) :: elapsed_time_average !! Average elapsed time for the benchmark in all images real ( rk ) :: elapsed_time_max !! Maximum elapsed time for the benchmark in all images real ( rk ) :: flops_total !! Total floating-point operations per second in all images real ( rk ) :: speedup_max_total !! Maximum speedup in all images compared to the reference benchmark contains procedure , private :: finalize_mark !! Finalize procedure for mark type end type mark !=============================================================================== !=============================================================================== type :: benchmark !! author: Seyed Ali Ghasemi !! Derived type for benchmarking and performance evaluation. !! type ( mark_co ), dimension (:), allocatable :: marks_co [:] !! Array of mark_co type for each method being benchmarked in each image type ( mark ), dimension (:), allocatable :: marks !! Array of mark type for each method being benchmarked in all images character (:), allocatable :: filename !! Filename for storing the benchmark data in all images character (:), allocatable :: filename_image !! Filename for storing the benchmark data in each image integer :: nloops !! Number of loops for each benchmark integer ( ik ), dimension (:), allocatable :: argi !! Integer arguments for benchmarks real ( rk ), dimension (:), allocatable :: argr !! Real arguments for benchmarks character (:), allocatable :: timer !! Timer object for measuring time integer :: imark !! Index of the current benchmark contains procedure :: init !! Initialization the benchmark object procedure :: start_benchmark !! Start a benchmark procedure :: stop_benchmark !! Stop a benchmark procedure , private :: write_benchmark !! Write benchmark data to file procedure :: finalize !! Finalize the benchmark object end type benchmark !=============================================================================== contains !=============================================================================== elemental impure subroutine init ( this , nmarks , title , filename , nloops , timer ) !! author: Seyed Ali Ghasemi !! Initialize the benchmark object. !! use , intrinsic :: iso_fortran_env , only : compiler_version , compiler_options class ( benchmark ), intent ( inout ) :: this !! Benchmark object integer , intent ( in ) :: nmarks !! Number of methods being benchmarked character ( * ), intent ( in ), optional :: title !! Title of the benchmark character ( * ), intent ( in ), optional :: filename !! Filename for storing the benchmark data integer , intent ( in ), optional :: nloops !! Number of loops for each benchmark (default: 10) character ( * ), intent ( in ), optional :: timer !! Timer object for measuring time (default: wall) integer :: nunit !! Unit number for file access integer :: iostat !! I/O status character ( 10 ) :: im_chr !! Character representation of the image number integer :: which_compiler !! Logical variables for compiler detection character (:), allocatable :: compiler !! Compiler name if ( nmarks <= 0 ) error stop 'nmarks must be greater than zero.' compiler = '' which_compiler = index ( compiler_version (), 'Intel(R) Fortran Compiler' ) if ( which_compiler /= 0 ) compiler = '_ifx' which_compiler = index ( compiler_version (), 'Intel(R) Fortran Intel(R)' ) if ( which_compiler /= 0 ) compiler = '_ifort' which_compiler = index ( compiler_version (), 'GCC' ) if ( which_compiler /= 0 ) compiler = '_gfortran' which_compiler = index ( compiler_version (), 'nvfortran' ) if ( which_compiler /= 0 ) compiler = '_nvfortran' write ( im_chr , '(i0)' ) this_image () if ( present ( filename )) then this % filename_image = trim ( filename // compiler // '_im' // trim ( im_chr ) // '.data' ) this % filename = trim ( filename // compiler // '_co' // '.data' ) else this % filename_image = trim ( 'benchmark' // compiler // '_im' // trim ( im_chr ) // '.data' ) this % filename = trim ( 'benchmark' // compiler // '_co' // '.data' ) end if if ( present ( nloops )) then if ( nloops <= 0 ) error stop 'nloops must be greater than zero.' this % nloops = nloops else this % nloops = 10 end if if ( present ( timer )) then select case ( trim ( timer )) case ( 'wall' ) this % timer = 'wall' case ( 'date_and_time' ) this % timer = 'date_and_time' case ( 'cpu' ) this % timer = 'cpu' case ( 'omp' ) #if defined(USE_OMP) this % timer = 'omp' #else error stop 'Use -DUSE_OMP to enable OpenMP.' #endif case ( 'mpi' ) #if defined(USE_MPI) this % timer = 'mpi' #else error stop 'Use -DUSE_MPI to enable MPI.' #endif case default error stop 'timer is not valid. Valid options are: wall, date_and_time, cpu, omp, mpi.' end select else this % timer = 'wall' end if allocate ( this % marks_co ( nmarks )[ * ]) allocate ( this % marks ( nmarks )) inquire ( file = this % filename_image , iostat = iostat ) if ( iostat /= 0 ) then error stop 'file ' // trim ( this % filename_image ) // ' cannot be accessed.' end if open ( newunit = nunit , file = this % filename_image ) write ( nunit , '(a)' ) '-----------------------------------------------------' write ( nunit , '(a)' ) 'ForBenchmark - https://github.com/gha3mi/forbenchmark' write ( nunit , '(a)' ) '-----------------------------------------------------' write ( nunit , '(a)' ) '' if ( present ( title )) then write ( nunit , '(a)' ) trim ( title ) else write ( nunit , '(a)' ) 'ForBenchmark' end if write ( nunit , '(a)' ) current_date_and_time () write ( nunit , '(a)' ) '' write ( nunit , '(a,a)' ) 'compiler_version: ' , compiler_version () write ( nunit , '(a,a)' ) 'compiler_options: ' , compiler_options () write ( nunit , '(a,g0,a,g0)' ) 'image: ' , this_image (), ' of ' , num_images () write ( nunit , '(a)' ) '' write ( nunit , '(a)' ) & & '       METHOD        |& &     TIME(image)      |& &    GFLOPS(image)     |& &  NLOOPS  |& &   ARGI  ' close ( nunit ) if ( this_image () == 1 ) then inquire ( file = this % filename , iostat = iostat ) if ( iostat /= 0 ) then error stop 'file ' // trim ( this % filename ) // ' cannot be accessed.' end if open ( newunit = nunit , file = this % filename ) write ( nunit , '(a)' ) '-----------------------------------------------------' write ( nunit , '(a)' ) 'ForBenchmark - https://github.com/gha3mi/forbenchmark' write ( nunit , '(a)' ) '-----------------------------------------------------' write ( nunit , '(a)' ) '' if ( present ( title )) then write ( nunit , '(a)' ) trim ( title ) else write ( nunit , '(a)' ) 'ForBenchmark' end if write ( nunit , '(a)' ) current_date_and_time () write ( nunit , '(a)' ) '' write ( nunit , '(a,a)' ) 'compiler_version: ' , compiler_version () write ( nunit , '(a,a)' ) 'compiler_options: ' , compiler_options () write ( nunit , '(a,g0)' ) 'num_image: ' , num_images () write ( nunit , '(a)' ) '' write ( nunit , '(a)' ) & & '       METHOD        |& & SPEEDUP(max) |& &      TIME(max)       |& &      TIME(min)       |& &      TIME(avg)       |& &     GFLOPS(tot)      |& &  NLOOPS  |& &   ARGI  ' close ( nunit ) end if end subroutine init !=============================================================================== !=============================================================================== impure subroutine start_benchmark ( this , imark , method , description , argi , argr ) !! author: Seyed Ali Ghasemi !! Start a specific benchmark. !! use face class ( benchmark ), intent ( inout ) :: this !! Benchmark object integer , intent ( in ) :: imark !! Index of the current method character ( * ), intent ( in ) :: method !! Name of the method being benchmarked integer ( ik ), dimension (:), intent ( in ), optional :: argi !! Integer arguments for benchmarks (optional) real ( rk ), dimension (:), intent ( in ), optional :: argr !! Real arguments for benchmarks (optional) character ( * ), intent ( in ), optional :: description !! Description of the method being benchmarked (optional) if ( imark <= 0 . or . imark > size ( this % marks )) error stop 'imark is out of range.' this % imark = imark this % marks ( this % imark )% description = description this % marks ( this % imark )% method = method if ( present ( argi )) then this % argi = argi else if (. not . allocated ( this % argi )) allocate ( this % argi ( 0 )) endif if ( present ( argr )) then this % argr = argr else if (. not . allocated ( this % argr )) allocate ( this % argr ( 0 )) endif sync all if ( present ( description ) . and . present ( argi ) . and . this_image () == 1 ) then print '(a,a,\" \",a,*(g0,1x))' ,& colorize ( 'Meth.: ' // this % marks ( this % imark )% method , color_fg = 'green' , style = 'bold_on' ),& colorize ( '; Des.: ' // this % marks ( this % imark )% description , color_fg = 'green_intense' ),& '; Argi.:' ,& this % argi elseif (. not . present ( description ) . and . present ( argi ) . and . this_image () == 1 ) then print '(a,\" \",a,*(g0,1x))' ,& colorize ( 'Meth.: ' // this % marks ( this % imark )% method , color_fg = 'green' , style = 'bold_on' ),& '; Argi.:' ,& this % argi elseif ( present ( description ) . and . . not . present ( argi ) . and . this_image () == 1 ) then print '(a,a)' ,& colorize ( 'Meth.: ' // this % marks ( this % imark )% method , color_fg = 'green' , style = 'bold_on' ),& colorize ( '; Des.: ' // this % marks ( this % imark )% description , color_fg = 'green_intense' ) elseif (. not . present ( description ) . and . . not . present ( argi ) . and . this_image () == 1 ) then print '(a)' , colorize ( 'Meth.: ' // this % marks ( this % imark )% method , color_fg = 'green' , style = 'bold_on' ) end if select case ( trim ( this % timer )) case ( 'wall' ) call this % marks_co ( this % imark )% time % timer_start () case ( 'date_and_time' ) call this % marks_co ( this % imark )% time % dtimer_start () case ( 'cpu' ) call this % marks_co ( this % imark )% time % ctimer_start () case ( 'omp' ) #if defined(USE_OMP) call this % marks_co ( this % imark )% time % ptimer_start () #else error stop 'Use -DUSE_OMP to enable OpenMP.' #endif case ( 'mpi' ) #if defined(USE_MPI) call this % marks_co ( this % imark )% time % mtimer_start () #else error stop 'Use -DUSE_MPI to enable MPI.' #endif end select end subroutine start_benchmark !=============================================================================== !=============================================================================== impure subroutine stop_benchmark ( this , flops ) !! author: Seyed Ali Ghasemi !! Stops the currently active benchmark, calculates performance metrics, and writes the results to the file and terminal. !! use face interface impure function Fun ( argi , argr ) import rk , ik integer ( ik ), dimension (:), intent ( in ), optional :: argi real ( rk ), dimension (:), intent ( in ), optional :: argr real ( rk ) :: Fun end function Fun end interface procedure ( Fun ), optional :: flops !! Function to calculate Floating Point Operations Per Second (optional) class ( benchmark ), intent ( inout ) :: this !! Benchmark object real ( rk ) :: elapsed_time_average !! Average elapsed time for the benchmark in all images real ( rk ) :: elapsed_time_min !! Minimum elapsed time for the benchmark in all images real ( rk ) :: elapsed_time_max !! Maximum elapsed time for the benchmark in all images real ( rk ) :: flops_total !! Total floating-point operations per second in all images real ( rk ), dimension (:), allocatable :: elapsed_times !! Array of elapsed times in all images integer :: i select case ( trim ( this % timer )) case ( 'wall' ) call this % marks_co ( this % imark )% time % timer_stop ( message = ' Elapsed time :' , nloops = this % nloops ) this % marks_co ( this % imark )% elapsed_time = this % marks_co ( this % imark )% time % elapsed_time case ( 'date_and_time' ) call this % marks_co ( this % imark )% time % dtimer_stop ( message = ' Elapsed time :' , nloops = this % nloops ) this % marks_co ( this % imark )% elapsed_time = this % marks_co ( this % imark )% time % elapsed_dtime case ( 'cpu' ) call this % marks_co ( this % imark )% time % ctimer_stop ( message = ' Elapsed time :' , nloops = this % nloops ) this % marks_co ( this % imark )% elapsed_time = this % marks_co ( this % imark )% time % cpu_time case ( 'omp' ) #if defined(USE_OMP) call this % marks_co ( this % imark )% time % otimer_stop ( message = ' Elapsed time :' , nloops = this % nloops ) this % marks_co ( this % imark )% elapsed_time = this % marks_co ( this % imark )% time % omp_time #else error stop 'Use -DUSE_OMP to enable OpenMP.' #endif case ( 'mpi' ) #if defined(USE_MPI) call this % marks_co ( this % imark )% time % mtimer_stop ( message = ' Elapsed time :' , nloops = this % nloops ) this % marks_co ( this % imark )% elapsed_time = this % marks_co ( this % imark )% time % mpi_time #else error stop 'Use -DUSE_MPI to enable MPI.' #endif end select if ( present ( flops )) then if ( this % marks_co ( this % imark )% elapsed_time <= epsilon ( 0.0_rk )) error stop 'Elapsed time is too small.' this % marks_co ( this % imark )% flops = flops ( this % argi , this % argr ) / this % marks_co ( this % imark )% elapsed_time print '(a,f7.3,a)' , ' Performance  :' , this % marks_co ( this % imark )% flops , ' [GFLOPS/image]' else this % marks_co ( this % imark )% flops = 0.0_rk end if sync all if ( this_image () == 1 ) then allocate ( elapsed_times ( num_images ())) do i = 1 , num_images () elapsed_times ( i ) = this % marks_co ( this % imark )[ i ]% elapsed_time end do elapsed_time_max = maxval ( elapsed_times ) elapsed_time_min = minval ( elapsed_times ) elapsed_time_average = sum ( elapsed_times ) / num_images () if ( present ( flops )) flops_total = 0.0_rk do i = 1 , num_images () if ( present ( flops )) flops_total = flops_total + this % marks_co ( this % imark )[ i ]% flops end do end if call co_broadcast ( elapsed_time_average , 1 ) call co_broadcast ( elapsed_time_min , 1 ) call co_broadcast ( elapsed_time_max , 1 ) if ( present ( flops )) call co_broadcast ( flops_total , 1 ) this % marks ( this % imark )% elapsed_time_average = elapsed_time_average this % marks ( this % imark )% elapsed_time_min = elapsed_time_min this % marks ( this % imark )% elapsed_time_max = elapsed_time_max if ( this % marks ( 1 )% elapsed_time_max <= epsilon ( 0.0_rk )) error stop 'Maximum elapsed time for the reference benchmark is too small.' this % marks ( this % imark )% speedup_max_total = this % marks ( this % imark )% elapsed_time_max / this % marks ( 1 )% elapsed_time_max if ( this_image () == 1 ) then print '(a,f7.3,a)' , colorize ( ' Elapsed time (max)     :' , color_fg = 'blue' ),& this % marks ( this % imark )% elapsed_time_max , ' [s]' print '(a,f7.3,a)' , colorize ( ' Elapsed time (min)     :' , color_fg = 'blue' ),& this % marks ( this % imark )% elapsed_time_min , ' [s]' print '(a,f7.3,a)' , colorize ( ' Elapsed time (average) :' , color_fg = 'blue' ),& this % marks ( this % imark )% elapsed_time_average , ' [s]' print '(a,f7.3,a)' , colorize ( ' Speedup (max)          :' , color_fg = 'blue' ),& this % marks ( this % imark )% speedup_max_total , ' [-]' if ( present ( flops )) print '(a,f7.3,a)' , colorize ( ' Performance  (total)   :' , color_fg = 'cyan' ),& flops_total , ' [GFLOPS]' print '(a)' , '' end if if ( present ( flops )) then this % marks ( this % imark )% flops_total = flops_total else this % marks ( this % imark )% flops_total = 0.0_rk end if call this % write_benchmark () end subroutine stop_benchmark !=============================================================================== !=============================================================================== impure subroutine write_benchmark ( this ) !! author: Seyed Ali Ghasemi !! Writes the benchmark data to a specified file, including method, speedup, elapsed time, flops, and other details. !! class ( benchmark ), intent ( inout ) :: this !! Benchmark object integer :: nunit !! Unit number for file access character ( len = 53 ) :: fmt1 !! Format for write character ( len = 82 ) :: fmt2 !! Format for write logical :: exist !! Logical variable for file existence integer :: iostat !! I/O status integer :: lm lm = 20 - len_trim ( this % marks ( this % imark )% method ) write ( fmt1 , '(a,g0,a)' )& '(a,' , lm , 'x,3x,E20.14,3x,E20.14,3x,g8.0,3x,*(g8.0,3x))' inquire ( file = this % filename_image , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename_image ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename_image , access = 'append' ) write ( nunit , fmt1 ) & this % marks ( this % imark )% method ,& this % marks_co ( this % imark )% time % elapsed_time ,& this % marks_co ( this % imark )% flops ,& this % nloops ,& this % argi close ( nunit ) if ( this_image () == 1 ) then write ( fmt2 , '(a,g0,a)' )& '(a,' , lm , 'x,3x,F12.6,3x,E20.14,3x,E20.14,3x,E20.14,3x,E20.14,3x,g8.0,3x,*(g20.0,3x))' inquire ( file = this % filename , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename , access = 'append' ) write ( nunit , fmt2 ) & this % marks ( this % imark )% method ,& this % marks ( this % imark )% speedup_max_total ,& this % marks ( this % imark )% elapsed_time_max ,& this % marks ( this % imark )% elapsed_time_min ,& this % marks ( this % imark )% elapsed_time_average ,& this % marks ( this % imark )% flops_total ,& this % nloops ,& this % argi close ( nunit ) end if end subroutine write_benchmark !=============================================================================== !=============================================================================== pure elemental subroutine finalize_mark ( this ) !! author: Seyed Ali Ghasemi !! Finalizes the mark object by deallocating allocated memory for method and description. !! class ( mark ), intent ( inout ) :: this !! Mark object to be finalized if ( allocated ( this % method )) deallocate ( this % method ) if ( allocated ( this % description )) deallocate ( this % description ) end subroutine finalize_mark !=============================================================================== !=============================================================================== elemental impure subroutine finalize ( this ) !! author: Seyed Ali Ghasemi !! Finalizes the benchmark object by deallocating memory and performs necessary cleanup. !! class ( benchmark ), intent ( inout ) :: this !! Benchmark object to be finalized integer :: nunit !! Unit number for file access logical :: exist !! Logical variable for file existence integer :: iostat !! I/O status inquire ( file = this % filename_image , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename_image ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename_image , access = 'append' ) write ( nunit , '(a)' ) 'end of benchmark' close ( nunit ) if ( this_image () == 1 ) then inquire ( file = this % filename , exist = exist , iostat = iostat ) if ( iostat /= 0 . or . . not . exist ) then error stop 'file ' // trim ( this % filename ) // ' does not exist or cannot be accessed.' end if open ( newunit = nunit , file = this % filename , access = 'append' ) write ( nunit , '(a)' ) 'end of benchmark' close ( nunit ) end if if ( allocated ( this % marks_co )) deallocate ( this % marks_co ) call this % marks % finalize_mark () if ( allocated ( this % marks )) deallocate ( this % marks ) if ( allocated ( this % filename_image )) deallocate ( this % filename_image ) if ( allocated ( this % argi )) deallocate ( this % argi ) if ( allocated ( this % argr )) deallocate ( this % argr ) if ( this_image () == 1 ) print '(a)' , 'end of benchmark' end subroutine finalize !=============================================================================== !=============================================================================== impure function current_date_and_time () result ( datetime ) !! author: Seyed Ali Ghasemi !! Retrieves the current date and time and returns it as a string !! It utilizes the intrinsic `date_and_time` function to obtain system time information. !! A string containing the current date and time in the format \"YYYY.MM.DD - HH:MM:SS\". !! character ( 21 ) :: datetime !! Character containing the current date and time character ( 10 ) :: date !! Character containing the current date character ( 8 ) :: time !! Character containing the current time integer :: values ( 8 ) !! Array containing the current date and time values character ( 4 ) :: year !! Current year character ( 2 ) :: month !! Current month character ( 2 ) :: day !! Current day character ( 2 ) :: hour !! Current hour character ( 2 ) :: minute !! Current minute character ( 2 ) :: second !! Current second call date_and_time ( values = values ) write ( year , '(i4)' ) values ( 1 ) write ( month , '(i2)' ) values ( 2 ) write ( day , '(i2)' ) values ( 3 ) write ( hour , '(i2)' ) values ( 5 ) write ( minute , '(i2)' ) values ( 6 ) write ( second , '(i2)' ) values ( 7 ) date = year // '.' // month // '.' // day time = hour // ':' // minute // ':' // second datetime = date // ' - ' // time end function current_date_and_time !=============================================================================== #endif end module forbenchmark_coarray","tags":"","loc":"sourcefile/forbenchmark_coarray.f90.html"},{"title":"demo.f90 – ForBenchmark","text":"This file depends on sourcefile~~demo.f90~~EfferentGraph sourcefile~demo.f90 demo.f90 sourcefile~forbenchmark.f90 forbenchmark.f90 sourcefile~demo.f90->sourcefile~forbenchmark.f90 sourcefile~forbenchmark_coarray.f90 forbenchmark_coarray.f90 sourcefile~forbenchmark.f90->sourcefile~forbenchmark_coarray.f90 sourcefile~forbenchmark_default.f90 forbenchmark_default.f90 sourcefile~forbenchmark.f90->sourcefile~forbenchmark_default.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! this is a demo program for forbenchmark. ! can be used for serial or coarray benchmarks. ! use -DUSE_COARRAY to compile for coarray benchmarks. program demo use kinds , only : rk , ik ! use -DREAL32 or -DREAL64 to switch between real32 and real64, default is real64 ! use -DINT32 or -DINT64 to switch between int32 and int64, default is int32 use forbenchmark , only : benchmark ! forbenchmark module implicit none ! benchmark object type ( benchmark ) :: bench ! define your variables here real ( rk ), dimension (:,:), allocatable :: A , B , C integer ( ik ) :: p integer ( ik ) :: nl , i , j , k ! initialize the benchmark ! nmarks: number of methods to benchmark ! title: optional ! filename: optional. make sure directory exists ! nloops: optional. number of loops for each benchmark. default is 10. ! timer: optional. default is 'wall'. other options are 'cpu', 'omp'. 'mpi', 'date_and_time' call bench % init ( nmarks = 2 , title = 'Demo Benchmark' , filename = 'results/demo' , nloops = 2 , timer = 'wall' ) ! start the benchmark do p = 600_ik , 900_ik , 100_ik ! loop over problem size !=============================================================================== ! allocate and initialize your variables here if ( allocated ( A )) deallocate ( A ) if ( allocated ( B )) deallocate ( B ) if ( allocated ( C )) deallocate ( C ) allocate ( A ( p , p )) allocate ( B ( p , p )) allocate ( C ( p , p ), source = 0.0_rk ) call random_number ( A ) call random_number ( B ) !=============================================================================== !=============================================================================== ! start benchmark for method 1 ! imark is an integer to identify the method, 1 is for reference method ! method is a string to identify the method ! description is optional ! argi is an optional integer array of arguments to write in the output file and to compute gflops ! the first element in argi is used for x-axis in the plot ! argr is an optional real array of arguments to compute gflops ! loop over nloops call bench % start_benchmark ( imark = 1 , method = 'm1' , description = 'intrinsic, C = matmul(A,B)' , argi = [ p , p , p ]) ! loop over nloops do nl = 1 , bench % nloops ! call your function or subroutine or ... ! here is used intrinsic matmul C = matmul ( A , B ) end do ! stop benchmark for method 1 ! flops is an optional function to compute flops call bench % stop_benchmark ( flops = cmp_gflops ) !=============================================================================== !=============================================================================== ! start benchmark for method 2, same as above. call bench % start_benchmark ( 2 , 'm2' , 'my_matmul, C = matmul(A,B)' , [ p , p , p ]) do nl = 1 , bench % nloops ! call your function or subroutine or ... ! here is used another matmul C = 0.0_rk do i = 1 , p do j = 1 , p do k = 1 , p C ( i , j ) = C ( i , j ) + A ( i , k ) * B ( k , j ) end do end do end do end do call bench % stop_benchmark ( cmp_gflops ) !=============================================================================== ! you can add more methods ... end do ! end loop over p ! finalize the benchmark call bench % finalize () ! you can use a python script to plot and export the results as follows: ! python results/export.py demo.data ! for coarray benchmarks, utilize: ! python results/export_co.py demo_co.data ! python results/export_im.py demo_im1.data ! python results/export_im.py demo_im2.data ! ... contains !=============================================================================== ! define an optional function to compute gflops function cmp_gflops ( argi , argr ) result ( gflops ) integer ( ik ), dimension (:), intent ( in ), optional :: argi real ( rk ), dimension (:), intent ( in ), optional :: argr real ( rk ) :: gflops gflops = real ( argi ( 1 ), rk ) * real ( argi ( 2 ), rk ) * real ( argi ( 3 ), rk ) * 1.0e-9_rk end function cmp_gflops !=============================================================================== end program demo","tags":"","loc":"sourcefile/demo.f90.html"}]}